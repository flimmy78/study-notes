(使用的uboot 版本：`u-boot-2016.07-rc1`)

## 1. make 命令

  详细命令可以使用 `make help` 或者文件 README 获取：

  ```
  ➜  u-boot-2016.05  make help
Cleaning targets:
  clean           - Remove most generated files but keep the config
  mrproper        - Remove all generated files + config + various backup files
  distclean       - mrproper + remove editor backup and patch files

Configuration targets:
  config          - Update current config utilising a line-oriented program
  nconfig         - Update current config utilising a ncurses menu based program
  menuconfig      - Update current config utilising a menu based program
  xconfig         - Update current config utilising a QT based front-end
  gconfig         - Update current config utilising a GTK based front-end
  oldconfig       - Update current config utilising a provided .config as base
  localmodconfig  - Update current config disabling modules not loaded
  localyesconfig  - Update current config converting local mods to core
  silentoldconfig - Same as oldconfig, but quietly, additionally update deps
  defconfig       - New config with default from ARCH supplied defconfig
  savedefconfig   - Save current config as ./defconfig (minimal config)
  allnoconfig     - New config where all options are answered with no
  allyesconfig    - New config where all options are accepted with yes
  allmodconfig    - New config selecting modules when possible
  alldefconfig    - New config with all symbols set to default
  randconfig      - New config with random answer to all options
  listnewconfig   - List new options
  olddefconfig    - Same as silentoldconfig but sets new symbols to their default value

Other generic targets:
  all             - Build all necessary images depending on configuration
* u-boot          - Build the bare u-boot
  dir/            - Build all files in dir and below
  dir/file.[oisS] - Build specified target only
  dir/file.lst    - Build specified mixed source/assembly target only
                    (requires a recent binutils and recent build (System.map))
  tags/ctags      - Generate ctags file for editors
  etags           - Generate etags file for editors
  cscope          - Generate cscope index
  ubootrelease    - Output the release version string (use with make -s)
  ubootversion    - Output the version stored in Makefile (use with make -s)

Static analysers
  checkstack      - Generate a list of stack hogs

Documentation targets:
 U-Boot bootloader internal documentation in different formats:
  htmldocs        - HTML
  pdfdocs         - PDF
  psdocs          - Postscript
  xmldocs         - XML DocBook
  mandocs         - man pages
  installmandocs  - install man pages generated by mandocs
  cleandocs       - clean all generated DocBook files

  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build
  make V=2   [targets] 2 => give reason for rebuild of target
  make O=dir [targets] Locate all output files in "dir", including .config
  make C=1   [targets] Check all c source with $CHECK (sparse by default)
  make C=2   [targets] Force check of all c source with $CHECK
  make RECORDMCOUNT_WARN=1 [targets] Warn about ignored mcount sections
  make W=n   [targets] Enable extra gcc checks, n=1,2,3 where
                1: warnings which may be relevant and do not occur too often
                2: warnings which occur quite often but may still be relevant
                3: more obscure warnings, can most likely be ignored
                Multiple levels can be combined with W=12 or W=123

Execute "make" or "make all" to build all targets marked with [*]
For further info see the ./README file
  ```

  其实常用到的命令就 4 个： `make xxx_defconfig` 、 `make clean` 、 `make mrproper` 、 `make -j N`, 注意：
    - 如果不是编译 x86 的 uboot，还需要显式的指出 `ARCH` 和 `CROSS_COMPILE` ， 可以在执行 make 时附带 `ARCH=xxx CROSS_COMPILE=yyy` 编译，也可以设置环境变量（`export ARCH=xxx`)。
    - xxx_defconfig 和你的目标板有关，比如 beaglebone black 的配置文件是 am335x_boneblack_defconfig，具体的配置文件名称可以在目录 `configs`（新版 uboot）或者文件 `boards.cfg` (旧版 uboot） 下找到。

## 2. make menuconfig

  新版的 u-boot 可以像 kernel 一样使用 menuconfig 配置参数（最新版的一定可以）

  ```
  make menuconfig
  ```

  效果图：


  ```

   .config - U-Boot 2016.05 Configuration
 ──────────────────────────────────────────────────────────────────────────────
  ┌───────────────────── U-Boot 2016.05 Configuration ──────────────────────┐
  │  Arrow keys navigate the menu.  <Enter> selects submenus ---> (or empty │
  │  submenus ----).  Highlighted letters are hotkeys.  Pressing <Y>        │
  │  includes, <N> excludes, <M> modularizes features.  Press <Esc><Esc> to │
  │  exit, <?> for Help, </> for Search.  Legend: [*] built-in  [ ]         │
  │ ┌─────────────────────────────────────────────────────────────────────┐ │
  │ │        Architecture select (ARM architecture)  --->                 │ │
  │ │        ARM architecture  --->                                       │ │
  │ │        General setup  --->                                          │ │
  │ │        Boot images  --->                                            │ │
  │ │        Boot timing  --->                                            │ │
  │ └────┴(+)─────────────────────────────────────────────────────────────┘ │
  ├─────────────────────────────────────────────────────────────────────────┤
  │        <Select>    < Exit >    < Help >    < Save >    < Load >         │
  └─────────────────────────────────────────────────────────────────────────┘

  ```

  注意，终端最小得是 80*19 大小。

## 3. 添加自定义的开发板配置文件

  按照 `xxx_defconfig` 这样的名称在 configs 目录下创建文件即可。

## 4. uboot shell 命令的实现

### 4.1. 添加命令

以命令 `boot` 为例（`cmd/bootm.c`），添加该命令使用了下面的语句：

```
U_BOOT_CMD(
    boot,   1,  1,  do_bootd,
    "boot default, i.e., run 'bootcmd'",
    ""
);
```

这段语句可以这么理解：给 uboot 添加了一条 shell 命令 `boot`，它的作用是引导、启动操作系统(`boot default, i.e., run 'bootcmd'`)，实现命令的函数是 `do_bootd`。

之所以这么一条语句就可以完成添加 shell 命令，可以参考 U_BOOT_CMD 的实现：

```
#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)      \
    U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)
```

```
#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \
    ll_entry_declare(cmd_tbl_t, _name, cmd) =           \
        U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,  \
                        _usage, _help, _comp);
```

```
#define ll_entry_declare(_type, _name, _list)               \
    _type _u_boot_list_2_##_list##_2_##_name __aligned(4)       \
            __attribute__((unused,              \
            section(".u_boot_list_2_"#_list"_2_"#_name)))
```

```
#define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,      \
                _usage, _help, _comp)           \
        { #_name, _maxargs, _rep, _cmd, _usage,         \
            _CMD_HELP(_help) _CMD_COMPLETE(_comp) }
```

```
# define _CMD_HELP(x) x,
# define _CMD_COMPLETE(x) x,
```

通过逐层解析宏 `U_BOOT_CMD`，最终会得到：

```
cmd_tbl_t _u_boot_list_2_cmd_2_boot __aligned(4) __attribute__((unused, section(".u_boot_list_2_cmd_2_boot"))) = {
        `boot`,
        1,
        1,
        do_bootd,
        "boot default, i.e., run 'bootcmd'",
        "",
        };


```

在 u-boot.lds 中会链接 .u_boot_list_2_cmd_2_boot ：

```
. = ALIGN(4);
.u_boot_list : {
 KEEP(*(SORT(.u_boot_list*)));
}
```

注：其中 SORT 会按照名称的的顺序进行链接。

cmd_tbl_t 定义如下(成员变量 complete 暂不讨论)：

```
typedef struct cmd_tbl_s    cmd_tbl_t;
struct cmd_tbl_s {
    char        *name;      /* Command Name         */
    int         maxargs;    /* maximum number of arguments  */
    int         repeatable; /* autorepeat allowed?      */
                    /* Implementation function  */
    int         (*cmd)(struct cmd_tbl_s *, int, int, char * const []);
    char        *usage;     /* Usage message    (short) */
#ifdef  CONFIG_SYS_LONGHELP
    char        *help;      /* Help  message    (long)  */
#endif
#ifdef CONFIG_AUTO_COMPLETE
    /* do auto completion on the arguments */
    int     (*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);
#endif
};
```

综上，  `U_BOOT_CMD(...)` 实际上是定义了一个结构体变量，这个结构体定义了 uboot 的 shell 命令要用到的信息，并且这个结构体变量是保存在指定的位置（`section(".u_boot_list_2_cmd_2_boot")`)。 uboot 运行时会主动在该 section 寻找命令并执行。

### 4.2. 执行命令

uboot 的 shell 入口是 `common/board_r.c` 的 run_main_loop() :

```
static int run_main_loop(void)
{
#ifdef CONFIG_SANDBOX
    sandbox_main_loop_init();
#endif
    /* main_loop() can return to retry autoboot, if so just run it again */
    for (;;)
        main_loop();
    return 0;
}
```

`main_loop()` 会重复执行，处理输入的命令

`common/main.c` 的 main_loop ：
```
/* We come here after U-Boot is initialised and ready to process commands */
void main_loop(void)
{
    const char *s;

...
    cli_init();
...
    s = bootdelay_process();
    if (cli_process_fdt(&s))
        cli_secure_boot_cmd(s);

    autoboot_command(s);

    cli_loop();
...
}
```

其中 `cli_loop()` 是执行命令的具体函数 ：

```
void cli_loop(void)
{
...
    parse_file_outer();
    /* This point is never reached */
    for (;;);
...
}
```

`parse_file_outer()` 会调用 `parse_stream_outer()` 解析输入的命令并调用 run_list() 执行命令 :

```
static int parse_stream_outer(struct in_str *inp, int flag)
{
...
    do {
        ...
            run_list(ctx.list_head);
...
    /* loop on syntax errors, return on EOF */
    } while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP) &&
        (inp->peek != static_peek || b_peek(inp)));
...
}
```

接着顺着函数调用链 `run_list() -> run_list_real() -> run_pipe_real() -> cmd_process()` uboot 进入到 cmd_process() 开始准备执行命令。

```
enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
                   int *repeatable, ulong *ticks)
{
    enum command_ret_t rc = CMD_RET_SUCCESS;
    cmd_tbl_t *cmdtp;

    /* Look up command in command table */
    cmdtp = find_cmd(argv[0]);
    if (cmdtp == NULL) {
        printf("Unknown command '%s' - try 'help'\n", argv[0]);
        return 1;
    }

    /* found - check max args */
    if (argc > cmdtp->maxargs)
        rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
    /* avoid "bootd" recursion */
    else if (cmdtp->cmd == do_bootd) {
        if (flag & CMD_FLAG_BOOTD) {
            puts("'bootd' recursion detected\n");
            rc = CMD_RET_FAILURE;
        } else {
            flag |= CMD_FLAG_BOOTD;
        }
    }
#endif

    /* If OK so far, then do the command */
    if (!rc) {
        if (ticks)
            *ticks = get_timer(0);
        rc = cmd_call(cmdtp, flag, argc, argv);
        if (ticks)
            *ticks = get_timer(*ticks);
        *repeatable &= cmdtp->repeatable;
    }
    if (rc == CMD_RET_USAGE)
        rc = cmd_usage(cmdtp);
    return rc;
}
```

其中 `find_cmd()` 用来在保存命令的 `u_boot_list*` 段内寻找命令对应的结构体变量，然后 `cmd_call()` 调用结构体变量对应的函数，到此命令执行完成。


### 4.3. 命令解析

命令解析有三部分：输入命令、找到命令、执行命令。

#### 4.3.1. 输入命令

uboot shell 的命令都是通过串口输入的，s用户输入字符串后会由 uboot 对字符串进行解析，最终获得命令、命令参数。

#### 4.3.2. 找到命令

通过串口输入获取到命令名称和命令参数后，要在 section .u_boot_list_2_cmd_2* 找到命令的结构体变量，根据结构体变量调用命令背后的函数。

寻找命令的函数是 `cmd_tbl_t *find_cmd()` ，函数返回了对应的命令结构体变量 ：

```
cmd_tbl_t *find_cmd(const char *cmd)
{
    cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
    const int len = ll_entry_count(cmd_tbl_t, cmd);
    return find_cmd_tbl(cmd, start, len);
}
```

```
#define ll_entry_start(_type, _list)                    \
({                                  \
    static char start[0] __aligned(4) __attribute__((unused,    \
        section(".u_boot_list_2_"#_list"_1")));         \
    (_type *)&start;                        \
})
```

```
#define ll_entry_count(_type, _list)                    \
    ({                              \
        _type *start = ll_entry_start(_type, _list);        \
        _type *end = ll_entry_end(_type, _list);        \
        unsigned int _ll_result = end - start;          \
        _ll_result;                     \
    })
```

```
#define ll_entry_end(_type, _list)                  \
({                                  \
    static char end[0] __aligned(4) __attribute__((unused,      \
        section(".u_boot_list_2_"#_list"_3")));         \
    (_type *)&end;                          \
})
```

而命令的结构体变量 `.u_boot_list_2_*_2*` 正好位于 `.u_boot_list_2_"#_list"_1"` 和 `.u_boot_list_2_"#_list"_3"` 之间，这样就获取到了 `.u_boot_list_2_*_2*` 的长度，然后调用函数 `find_cmd_tbl()` 遍历该 section 、寻找命令对应的结构体变量并返回给 shell。


```
cmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)
{
...
    for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
        if (strncmp(cmd, cmdtp->name, len) == 0) {
            if (len == strlen(cmdtp->name))
                return cmdtp;   /* full match */

            cmdtp_temp = cmdtp; /* abbreviated command ? */
            n_found++;
        }
    }
...
}
```

#### 4.3.3. 执行命令

cmd_process() 调用 cmd_call() 执行命令，很简单就是直接调用命令结构体变量的成员函数 ：

```
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
   ...
    result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
   ....
}
```

## 5. boot os

uboot 主要用来引导 linux ， 一般情况下使用下列命令就可以启动嵌入式 linux ：

```
echo load ramdisk
cp.b $ramdisk_addr 2000000 400000
echo load uImage
cp.b $kernel_addr 1000000 500000
echo load dtb
cp.b $dts_addr 3000000 4000
echo booting
bootm 0x1000000 0x2000000 0x3000000
```

上面的命令通过 `cp` 将 linux 系统的 ramdisk 、 设备树 、 kernel 从 flash 拷贝到内存，然后调用 `bootm` 命令启动系统。

或者，直接输入命令 `boot` 也可以启动系统，而实际上输入 boot 后 uboot 会自动执行上述命令。

### 5.1. 引导系统的命令

和引导系统有关的命令主要有 `boot` 、`bootd` 、`bootm` 、`bootz` 、`bootvx` 、`bootp` `go`，以及加载系统文件的命令 `cp` 、`tftp` 、`fatload` 、`extload` 、`run` 等。

以下是如要的 `boot*` 命令

- `boot` 和 `bootd` 等价，后者是以前的命令名，现在存在的唯一意义就是向后兼容。 `boot` 命令是通过函数 `do_bootd()` 实现的 ：

  ```
  int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
  {
      return run_command(getenv("bootcmd"), flag);
  }
  ```

  如代码所示， `boot` 实际上就是运行 shell 变量 bootcmd 所代表的一串命令，比如：

  ```
  bootcmd=run findfdt; run init_console; run envboot; run distro_bootcmd
  ```

  `boot` 启动系统时只需要在 shell 输入命令本身即可，或者等待 uboot 自己调用 `boot` (uboot 默认会执行 boot 启动 linux)。

- `bootm` 从内存引导系统，启动系统大多依赖这条命令（以及命令 `go`）， `bootm` 启动 linux 时一般需要三个参数 ： kernel 地址、ramdisk 地址和设备树地址，比如：

  ```
  bootm $kernel_addr $ramdisk_addr $dtb_addr
  ```
- `bootz` 用来启动内存中的 zImage linux 系统镜像。参数于 `bootm` 相同

### 5.2. 引导系统的过程

1. `boot` 命令本身很简单，其实现依赖于 `bootm`。
2. `bootm` 和 `bootz` 引导 linux 都主要依赖函数 `do_bootm_states()`。

bootm 的实现(p1020 和 zynq 使用了这种方式)：

```
int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
...
    /* determine if we have a sub command */
    argc--; argv++;
    if (argc > 0) {
        char *endp;

        simple_strtoul(argv[0], &endp, 16);

        if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
            return do_bootm_subcommand(cmdtp, flag, argc, argv);
    }

    return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |
        BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
        BOOTM_STATE_LOADOS |
#if defined(CONFIG_PPC) || defined(CONFIG_MIPS)
        BOOTM_STATE_OS_CMDLINE |
#endif
        BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
        BOOTM_STATE_OS_GO, &images, 1);
}
```

bootz 的实现（beaglebone black 采用了这种方式）：

```
int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
...
    if (bootz_start(cmdtp, flag, argc, argv, &images))
        return 1;
...
    images.os.os = IH_OS_LINUX;
    ret = do_bootm_states(cmdtp, flag, argc, argv,
                  BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
                  BOOTM_STATE_OS_GO,
                  &images, 1);
...
}
```

可以看出 `bootz` 和 `bootm` 要引导系统最终都由 `do_bootm_states()` 完成。 `do_bootm()` 里的 `do_bootm_subcommand()` 只是用来处理一些 `bootm` 的字命令。`do_bootz()` 中的 `bootz_start()` 也只是为最后启动操作系统做一些检查和预备工作。

`do_bootm_subcommand()` 的实现很简单只是执行对应的命令函数，然后标记一下启动的过程。

```
static int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
            char * const argv[])
{
    int ret = 0;
    long state;
    cmd_tbl_t *c;

    c = find_cmd_tbl(argv[0], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
    argc--; argv++;

    if (c) {
        state = (long)c->cmd;
        if (state == BOOTM_STATE_START)
            state |= BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER;
    } else {
        /* Unrecognized command */
        return CMD_RET_USAGE;
    }

    if (((state & BOOTM_STATE_START) != BOOTM_STATE_START) &&
        images.state >= state) {
        printf("Trying to execute a command out of order\n");
        return CMD_RET_USAGE;
    }

    ret = do_bootm_states(cmdtp, flag, argc, argv, state, &images, 0);

    return ret;
}
```

`bootz_start()` 会设置好 zImage 的入口，加载 ramdisk 、设备树和其他一下琐碎到内存。

```
static int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc,
            char * const argv[], bootm_headers_t *images)
{
    int ret;
    ulong zi_start, zi_end;

    ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,
                  images, 1);

    /* Setup Linux kernel zImage entry point */
    if (!argc) {
        images->ep = load_addr;
        debug("*  kernel: default image load address = 0x%08lx\n",
                load_addr);
    } else {
        images->ep = simple_strtoul(argv[0], NULL, 16);
        debug("*  kernel: cmdline image address = 0x%08lx\n",
            images->ep);
    }

    ret = bootz_setup(images->ep, &zi_start, &zi_end);
    if (ret != 0)
        return 1;

    lmb_reserve(&images->lmb, images->ep, zi_end - zi_start);

    /*
     * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not
     * have a header that provide this informaiton.
     */
    if (bootm_find_images(flag, argc, argv))
        return 1;

    return 0;
}
```

`bootm_find_images()` 加载 ramdisk 和设备树等文件到内存：

```
int bootm_find_images(int flag, int argc, char * const argv[])
{
    int ret;

    /* find ramdisk */
    ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
                   &images.rd_start, &images.rd_end);
...
#if IMAGE_ENABLE_OF_LIBFDT
    /* find flattened device tree */
    ret = boot_get_fdt(flag, argc, argv, IH_ARCH_DEFAULT, &images,
               &images.ft_addr, &images.ft_len);
    if (ret) {
        puts("Could not find a valid device tree\n");
        return 1;
    }
    set_working_fdt_addr((ulong)images.ft_addr);
#endif
...
    return 0;
}
```

3. **`do_bootm_states()`**


```
/**
 * Execute selected states of the bootm command.
 *
 * Note the arguments to this state must be the first argument, Any 'bootm'
 * or sub-command arguments must have already been taken.
 *
 * Note that if states contains more than one flag it MUST contain
 * BOOTM_STATE_START, since this handles and consumes the command line args.
 *
 * Also note that aside from boot_os_fn functions and bootm_load_os no other
 * functions we store the return value of in 'ret' may use a negative return
 * value, without special handling.
 *
 * @param cmdtp     Pointer to bootm command table entry
 * @param flag      Command flags (CMD_FLAG_...)
 * @param argc      Number of subcommand arguments (0 = no arguments)
 * @param argv      Arguments
 * @param states    Mask containing states to run (BOOTM_STATE_...)
 * @param images    Image header information
 * @param boot_progress 1 to show boot progress, 0 to not do this
 * @return 0 if ok, something else on error. Some errors will cause this
 *  function to perform a reboot! If states contains BOOTM_STATE_OS_GO
 *  then the intent is to boot an OS, so this function will not return
 *  unless the image type is standalone.
 */

int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
		    int states, bootm_headers_t *images, int boot_progress)
{
	boot_os_fn *boot_fn;
	ulong iflag = 0;
	int ret = 0, need_boot_fn;

	images->state |= states;

	/*
	 * Work through the states and see how far we get. We stop on
	 * any error.
	 */
	if (states & BOOTM_STATE_START)
		ret = bootm_start(cmdtp, flag, argc, argv);

	if (!ret && (states & BOOTM_STATE_FINDOS))
		ret = bootm_find_os(cmdtp, flag, argc, argv);

	if (!ret && (states & BOOTM_STATE_FINDOTHER)) {
		ret = bootm_find_other(cmdtp, flag, argc, argv);
		argc = 0;	/* consume the args */
	}

	/* Load the OS */
	if (!ret && (states & BOOTM_STATE_LOADOS)) {
		ulong load_end;

		iflag = bootm_disable_interrupts();
		ret = bootm_load_os(images, &load_end, 0);
		if (ret == 0)
			lmb_reserve(&images->lmb, images->os.load,
				    (load_end - images->os.load));
		else if (ret && ret != BOOTM_ERR_OVERLAP)
			goto err;
		else if (ret == BOOTM_ERR_OVERLAP)
			ret = 0;
#if defined(CONFIG_SILENT_CONSOLE) && !defined(CONFIG_SILENT_U_BOOT_ONLY)
		if (images->os.os == IH_OS_LINUX)
			fixup_silent_linux();
#endif
	}

	/* Relocate the ramdisk */
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
	if (!ret && (states & BOOTM_STATE_RAMDISK)) {
		ulong rd_len = images->rd_end - images->rd_start;

		ret = boot_ramdisk_high(&images->lmb, images->rd_start,
			rd_len, &images->initrd_start, &images->initrd_end);
		if (!ret) {
			setenv_hex("initrd_start", images->initrd_start);
			setenv_hex("initrd_end", images->initrd_end);
		}
	}
#endif
#if IMAGE_ENABLE_OF_LIBFDT && defined(CONFIG_LMB)
	if (!ret && (states & BOOTM_STATE_FDT)) {
		boot_fdt_add_mem_rsv_regions(&images->lmb, images->ft_addr);
		ret = boot_relocate_fdt(&images->lmb, &images->ft_addr,
					&images->ft_len);
	}
#endif

	/* From now on, we need the OS boot function */
	if (ret)
		return ret;
	boot_fn = bootm_os_get_boot_func(images->os.os);
	need_boot_fn = states & (BOOTM_STATE_OS_CMDLINE |
			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);
	if (boot_fn == NULL && need_boot_fn) {
		if (iflag)
			enable_interrupts();
		printf("ERROR: booting os '%s' (%d) is not supported\n",
		       genimg_get_os_name(images->os.os), images->os.os);
		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
		return 1;
	}

	/* Call various other states that are not generally used */
	if (!ret && (states & BOOTM_STATE_OS_CMDLINE))
		ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);
	if (!ret && (states & BOOTM_STATE_OS_BD_T))
		ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);
	if (!ret && (states & BOOTM_STATE_OS_PREP))
		ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);

#ifdef CONFIG_TRACE
	/* Pretend to run the OS, then run a user command */
	if (!ret && (states & BOOTM_STATE_OS_FAKE_GO)) {
		char *cmd_list = getenv("fakegocmd");

		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,
				images, boot_fn);
		if (!ret && cmd_list)
			ret = run_command_list(cmd_list, -1, flag);
	}
#endif

	/* Check for unsupported subcommand. */
	if (ret) {
		puts("subcommand not supported\n");
		return ret;
	}

	/* Now run the OS! We hope this doesn't return */
	if (!ret && (states & BOOTM_STATE_OS_GO))
		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,
				images, boot_fn);

	/* Deal with any fallout */
err:
	if (iflag)
		enable_interrupts();

	if (ret == BOOTM_ERR_UNIMPLEMENTED)
		bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
	else if (ret == BOOTM_ERR_RESET)
		do_reset(cmdtp, flag, argc, argv);

	return ret;
}
```

从注释就可以看出该函数要启动 Linux 需要的参数：启动命令（cmdtp,argv）、linux 镜像头(images)以及启动过程和状态(flag,states,boot_progress)。

states 用来判断引导系统进行到了哪一步，不同阶段有不同的分支代码要执行。如代码中的 `ret = bootm_start(cmdtp, flag, argc, argv);`（设置之后获取到的内核镜像的大小和位置） , `ret = bootm_find_os(cmdtp, flag, argc, argv);`（获取要引导的内核镜像） 等。

分支 `if (!ret && (states & BOOTM_STATE_LOADOS)) { ... }` 会将内核**解压**、**读取**到内存之前设定位置。接下来就是加载 ramdisk 和 设备树。如果上面几步都执行正确，那么接下来就是根据不同的内核类型获取不同系统引导函数:

```
boot_fn = bootm_os_get_boot_func(images->os.os);
need_boot_fn = states & (BOOTM_STATE_OS_CMDLINE |
        BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
        BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);
```

执行系统引导函数时还要根据 states 的内容给 `boot_fn` 传入不同的参数。在最后启动、进入 linux 之前，如果还要进行追踪，可以调用 `getenv()` 和 `run_command_list()` 获取并执行命令（比如执行 fakegocmd 进行追踪）。最后 uboot 执行函数 `boot_selected_os()` 启动操作系统，其实最终调用的还是 `boot_fn()` ，不过传入的参数与之前不同而已。

4. `boot_fn()`

实际启动系统的函数 `boot_fn()` 实际上有一组函数，在 `do_bootm_states()` 中通过 `bootm_os_get_boot_func()` 获取：

```
boot_fn = bootm_os_get_boot_func(images->os.os);
```

```
boot_os_fn *bootm_os_get_boot_func(int os)
{
    return boot_os[os];
}

static boot_os_fn *boot_os[] = {
    [IH_OS_U_BOOT] = do_bootm_standalone,
#ifdef CONFIG_BOOTM_LINUX
    [IH_OS_LINUX] = do_bootm_linux,
#endif
#ifdef CONFIG_BOOTM_NETBSD
    [IH_OS_NETBSD] = do_bootm_netbsd,
#endif
#ifdef CONFIG_LYNXKDI
    [IH_OS_LYNXOS] = do_bootm_lynxkdi,
#endif
#ifdef CONFIG_BOOTM_RTEMS
    [IH_OS_RTEMS] = do_bootm_rtems,
#endif
#if defined(CONFIG_BOOTM_OSE)
    [IH_OS_OSE] = do_bootm_ose,
#endif
#if defined(CONFIG_BOOTM_PLAN9)
    [IH_OS_PLAN9] = do_bootm_plan9,
#endif
#if defined(CONFIG_BOOTM_VXWORKS) && \
    (defined(CONFIG_PPC) || defined(CONFIG_ARM))
    [IH_OS_VXWORKS] = do_bootm_vxworks,
#endif
#if defined(CONFIG_CMD_ELF)
    [IH_OS_QNX] = do_bootm_qnxelf,
#endif
#ifdef CONFIG_INTEGRITY
    [IH_OS_INTEGRITY] = do_bootm_integrity,
#endif
#ifdef CONFIG_BOOTM_OPENRTOS
    [IH_OS_OPENRTOS] = do_bootm_openrtos,
#endif
};
```

从代码可以看出 uboot 可以支持引导多种操作系统，比如 Linux 、 NetBSD 、 VxWorks 、 OpenRTOS 等。以引导 Linux 的 `do_bootm_linux()` 为例。

`do_bootm_linux()` 是区分架构的，比如 arm 、powerpc 、 mips 、 x86 等。

```
  1 F   f    do_bootm_linux    arch/arc/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
  2 F   f    do_bootm_linux    arch/arm/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[],
  3 F   f    do_bootm_linux    arch/avr32/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images)
  4 F   f    do_bootm_linux    arch/blackfin/lib/boot.c
               int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images)
  5 F   f    do_bootm_linux    arch/m68k/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images)
  6 F   f    do_bootm_linux    arch/microblaze/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[],
  7 F   f    do_bootm_linux    arch/mips/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[],
  8 F   f    do_bootm_linux    arch/nds32/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
  9 F   f    do_bootm_linux    arch/nios2/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images)
 10 F   f    do_bootm_linux    arch/openrisc/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[],
 11 F   f    do_bootm_linux    arch/powerpc/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images)
 12 F   f    do_bootm_linux    arch/sandbox/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
 13 F   f    do_bootm_linux    arch/sh/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images)
 14 F   f    do_bootm_linux    arch/sparc/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t * images)
 15 F   f    do_bootm_linux    arch/x86/lib/bootm.c
               int do_bootm_linux(int flag, int argc, char * const argv[],
```

只看 arm 版的 `do_bootm_linux()` 的代码：

```
int do_bootm_linux(int flag, int argc, char * const argv[],
           bootm_headers_t *images)
{
    /* No need for those on ARM */
    if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
        return -1;

    if (flag & BOOTM_STATE_OS_PREP) {
        boot_prep_linux(images);
        return 0;
    }

    if (flag & (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) {
        boot_jump_linux(images, flag);
        return 0;
    }

    boot_prep_linux(images);
    boot_jump_linux(images, flag);
    return 0;
}
```

```
static void boot_prep_linux(bootm_headers_t *images)
{
    char *commandline = getenv("bootargs");

    if (IMAGE_ENABLE_OF_LIBFDT && images->ft_len) {
#ifdef CONFIG_OF_LIBFDT
        debug("using: FDT\n");
        if (image_setup_linux(images)) {
            printf("FDT creation failed! hanging...");
            hang();
        }
#endif
    } else if (BOOTM_ENABLE_TAGS) {
        debug("using: ATAGS\n");
        setup_start_tag(gd->bd);
        if (BOOTM_ENABLE_SERIAL_TAG)
            setup_serial_tag(&params);
        if (BOOTM_ENABLE_CMDLINE_TAG)
            setup_commandline_tag(gd->bd, commandline);
        if (BOOTM_ENABLE_REVISION_TAG)
            setup_revision_tag(&params);
        if (BOOTM_ENABLE_MEMORY_TAGS)
            setup_memory_tags(gd->bd);
        if (BOOTM_ENABLE_INITRD_TAG) {
            /*
             * In boot_ramdisk_high(), it may relocate ramdisk to
             * a specified location. And set images->initrd_start &
             * images->initrd_end to relocated ramdisk's start/end
             * addresses. So use them instead of images->rd_start &
             * images->rd_end when possible.
             */
            if (images->initrd_start && images->initrd_end) {
                setup_initrd_tag(gd->bd, images->initrd_start,
                         images->initrd_end);
            } else if (images->rd_start && images->rd_end) {
                setup_initrd_tag(gd->bd, images->rd_start,
                         images->rd_end);
            }
        }
        setup_board_tags(&params);
    } else {
        printf("FDT and ATAGS support not compiled in - hanging\n");
        hang();
    }
}
```

```
int image_setup_linux(bootm_headers_t *images)
{
    ulong of_size = images->ft_len;
    char **of_flat_tree = &images->ft_addr;
    ulong *initrd_start = &images->initrd_start;
    ulong *initrd_end = &images->initrd_end;
    struct lmb *lmb = &images->lmb;
    ulong rd_len;
    int ret;

    if (IMAGE_ENABLE_OF_LIBFDT)
        boot_fdt_add_mem_rsv_regions(lmb, *of_flat_tree);

    if (IMAGE_BOOT_GET_CMDLINE) {
        ret = boot_get_cmdline(lmb, &images->cmdline_start,
                &images->cmdline_end);
        if (ret) {
            puts("ERROR with allocation of cmdline\n");
            return ret;
        }
    }
    if (IMAGE_ENABLE_RAMDISK_HIGH) {
        rd_len = images->rd_end - images->rd_start;
        ret = boot_ramdisk_high(lmb, images->rd_start, rd_len,
                initrd_start, initrd_end);
        if (ret)
            return ret;
    }

    if (IMAGE_ENABLE_OF_LIBFDT) {
        ret = boot_relocate_fdt(lmb, of_flat_tree, &of_size);
        if (ret)
            return ret;
    }

    if (IMAGE_ENABLE_OF_LIBFDT && of_size) {
        ret = image_setup_libfdt(images, *of_flat_tree, of_size, lmb);
        if (ret)
            return ret;
    }

    return 0;
}
```

```
static void boot_jump_linux(bootm_headers_t *images, int flag)
{
#ifdef CONFIG_ARM64
    void (*kernel_entry)(void *fdt_addr, void *res0, void *res1,
            void *res2);
    int fake = (flag & BOOTM_STATE_OS_FAKE_GO);

    kernel_entry = (void (*)(void *fdt_addr, void *res0, void *res1,
                void *res2))images->ep;

    debug("## Transferring control to Linux (at address %lx)...\n",
        (ulong) kernel_entry);
    bootstage_mark(BOOTSTAGE_ID_RUN_OS);

    announce_and_cleanup(fake);
    
    if (!fake) {
        do_nonsec_virt_switch();
        kernel_entry(images->ft_addr, NULL, NULL, NULL);
    }
#else
    unsigned long machid = gd->bd->bi_arch_number;
    char *s;
    void (*kernel_entry)(int zero, int arch, uint params);
    unsigned long r2;
    int fake = (flag & BOOTM_STATE_OS_FAKE_GO);

    kernel_entry = (void (*)(int, int, uint))images->ep;

    s = getenv("machid");
    if (s) {
        if (strict_strtoul(s, 16, &machid) < 0) {
            debug("strict_strtoul failed!\n");
            return;
        }
        printf("Using machid 0x%lx from environment\n", machid);
    }

    debug("## Transferring control to Linux (at address %08lx)" \
        "...\n", (ulong) kernel_entry);
    bootstage_mark(BOOTSTAGE_ID_RUN_OS);
    announce_and_cleanup(fake);

    if (IMAGE_ENABLE_OF_LIBFDT && images->ft_len)
        r2 = (unsigned long)images->ft_addr;
    else
        r2 = gd->bd->bi_boot_params;

    if (!fake) {
#ifdef CONFIG_ARMV7_NONSEC
        if (armv7_boot_nonsec()) {
            armv7_init_nonsec();
            secure_ram_addr(_do_nonsec_entry)(kernel_entry,
                              0, machid, r2);
        } else
#endif
            kernel_entry(0, machid, r2);
    }
#endif
}
```

`boot_prep_linux()` 和 `image_setup_linux()` 用来做一些正式启动前的处理工作（**此处待补充**）， `boot_jump_linux()` 用来生成进入系统的入口点（`kernel_entry`），而入口点的信息都是之前函数处理好的，此处只是进行一个跳转而已：

```
kernel_entry = (void (*)(void *fdt_addr, void *res0, void *res1,
            void *res2))images->ep;
...
if (!fake) {
    do_nonsec_virt_switch();
    kernel_entry(images->ft_addr, NULL, NULL, NULL);
}
```

到此就要进入 linux 了，结束了 uboot 的代码，arm 版的 `boot_fn()` 结束。

5. `kernel_entry` 的实现

在 uboot 中执行了 `kernel_entry()` 就要进入 Linux 了。

```
...
kernel_entry(images->ft_addr, NULL, NULL, NULL);
...
```

这在一般的 bootloader 中很常见，对于一般的系统来说，`kernel_entry()` 实际上指向了对应操作系统的入口函数的地址，比如 `main()`，根据需要或许还要传入一些参数，执行 `main()` 时就已经进入到 操作系统的代码了，操作系统接管 CPU 开始了它自己的初始化、配置等工作。

## 5. 驱动框架

1. 声明

  每个设备在 uboot 中都对应一个驱动结构体变量， uboot 操纵外设都是通过该结构体变量实现的。以 ti 的 cpsw 网卡为例，在 `driver/net/cpsw.c` 中定义了多个函数实现了网卡的收发、配置、中断处理等操作，然后通过结构体将这些操作集成到操作结构体 `struct eth_ops` 中：
  
  ```
  static const struct eth_ops cpsw_eth_ops = { 
    .start      = cpsw_eth_start,
    .send       = cpsw_eth_send,
    .recv       = cpsw_eth_recv,
    .free_pkt   = cpsw_eth_free_pkt,
    .stop       = cpsw_eth_stop,
  };
  ```
  
  这个结构体包含了网卡的主要操作：启停、收发等操作，但是这个结构体还是太底层了，不应该直接传给上层应用，也不能传给上层，uboot 的外设驱动架构是把全部的驱动放到一个 **section 群**中，驱动结构体的成员是统一的，cpsw 驱动结构提其组成如下：
  
  ```
  U_BOOT_DRIVER(eth_cpsw) = {
    .name   = "eth_cpsw",
    .id = UCLASS_ETH,
    .of_match = cpsw_eth_ids,
    .ofdata_to_platdata = cpsw_eth_ofdata_to_platdata,
    .probe  = cpsw_eth_probe,
    .ops    = &cpsw_eth_ops,
    .priv_auto_alloc_size = sizeof(struct cpsw_priv),
    .platdata_auto_alloc_size = sizeof(struct eth_pdata),
    .flags = DM_FLAG_ALLOC_PRIV_DMA, 
  };
  ```
  
  cpsw 驱动的成员包括了驱动名（name）、id、类型（of_match)、探针（probe）、操作（ops）等等。而这些驱动都是保存在同一个 **section 群**中，这是通过宏 `U_BOOT_DRIVER` 实现的：
  
  ```
  /* Declare a new U-Boot driver */
  #define U_BOOT_DRIVER(__name)                       \
    ll_entry_declare(struct driver, __name, driver)

  #define ll_entry_declare(_type, _name, _list)               \
    _type _u_boot_list_2_##_list##_2_##_name __aligned(4)       \
            __attribute__((unused,              \
            section(".u_boot_list_2_"#_list"_2_"#_name)))  
  
  struct driver {
    char *name;
    enum uclass_id id;
    const struct udevice_id *of_match;
    int (*bind)(struct udevice *dev);
    int (*probe)(struct udevice *dev);
    int (*remove)(struct udevice *dev);
    int (*unbind)(struct udevice *dev);
    int (*ofdata_to_platdata)(struct udevice *dev);
    int (*child_post_bind)(struct udevice *dev);
    int (*child_pre_probe)(struct udevice *dev);
    int (*child_post_remove)(struct udevice *dev);
    int priv_auto_alloc_size;
    int platdata_auto_alloc_size;
    int per_child_auto_alloc_size;
    int per_child_platdata_auto_alloc_size;
    const void *ops;    /* driver-specific operations */
    uint32_t flags;
  };
  ```
  
  这和之前 shell command 的实现类似。此处网卡驱动 `eth_cpsw` 的结构体就是一个定义在段 `.u_boot_list_2_driver_2_eth_cpsw` 的 `struct driver` 结构体（`_u_boot_list_2_driver_2_eth_cpsw`)，定义好网卡驱动之后，其它应用就知道了结构体的名字和位置，从而可以使用该驱动。

2. 调用

  首先注册驱动，将具体设备的驱动和 uboot 的全局结构体（got？）关联起来。
  
  然后通过全局结构体调用具体的设备驱动。
  
  ```
  int eth_send(void *packet, int length)
  {
    ...
    return eth_current->send(eth_current, packet, length);
  } 
  ```
  
  uboot 通过 `eth_current->send` 调用了实际网络设备的发送函数。现在要关注的是 eth_current 实际指向的驱动是哪个，以及该变量是何时、何处赋值的。
  
  
  

  
  
                                                      

  


## 6. startup (armv7)

CPU 上电自动进入默认的 reset 中断向量入口，开始执行 uboot 启动汇编(`arch/arm/cpu/armv7/start.S`)

```
/*************************************************************************
 *
 * Startup Code (reset vector)
 *
 * Do important init only if we don't start from memory!
 * Setup memory and board specific bits prior to relocation.
 * Relocate armboot to ram. Setup stack.
 *
 *************************************************************************/

    .globl  reset
    .globl  save_boot_params_ret

reset:
    /* Allow the board to save important registers */
    b   save_boot_params
```

接下来关中断进入 SVC 模式，设置自己的中断向量表地址（将地址写到 SCTLR 寄存器），初始化 CPU (根据实际不同处理器需求)，然后进入 C 运行时代码（`bl _main`）。

`_main` 位于 `arch/arm/lib/crt0.S` ，此处代码是独立于硬件的，主要用来初始化硬件配置和为接下来的 C 语言提供运行环境（提供 stack 环境等），最终进入 uboot 的主循环。

```
 /*
  * entry point of crt0 sequence
  */

 ENTRY(_main)

...
 ldr sp, =(CONFIG_SYS_INIT_SP_ADDR)     /*配置 stack*/ 
...
 bl  board_init_f_init_reserve           /*初始化 gd 结构体*/    
...
 bl  board_init_f                        /* 初始化外设和相关数据结构*/
...
 ldr r0, =__bss_start    /* this is auto-relocated! */
 ldr r1, =__bss_end      /* this is auto-relocated! */
 mov r2, #0x00000000     /* prepare zero to clear BSS */
...
 b   relocate_code      /* 将代码拷贝到 ddr*/
...
    /* call board_init_r(gd_t *id, ulong dest_addr) */
    mov     r0, r9                  /* gd_t */
    ldr r1, [r9, #GD_RELOCADDR] /* dest_addr */
    /* call board_init_r */
    ldr pc, =board_init_r   /* this is auto-relocated! */
...
 ENDPROC(_main)
```

注： 有的开发板的 uboot 会要求生成两个 bin 文件 ： u-boot.bin 和 u-boot-spl.bin，此处先只讨论 u-boot.bin。

进入 `board_init_f()` 后会分步骤的初始化外设、将代码拷贝到 DDR 内存。

```
void board_init_f(ulong boot_flags)
{
...
    if (initcall_run_list(init_sequence_f))
        hang();       
...
}
```

`initcall_run_list()` 用来执行结构体数组 `init_sequence_f` 定义的一系列配置初始化函数，而 `init_sequence_f` 包含的初始化函数如下：

```
static init_fnc_t init_sequence_f[] = {
#ifdef CONFIG_SANDBOX
    setup_ram_buf,
#endif
    setup_mon_len,
#ifdef CONFIG_OF_CONTROL
    fdtdec_setup,
#endif
#ifdef CONFIG_TRACE
    trace_early_init,
#endif
    initf_malloc,
    initf_console_record,
#if defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)
    /* TODO: can this go into arch_cpu_init()? */
    probecpu,
#endif
#if defined(CONFIG_X86) && defined(CONFIG_HAVE_FSP)
    x86_fsp_init,
#endif
    arch_cpu_init,      /* basic arch cpu dependent setup */
    initf_dm,
    arch_cpu_init_dm,
    mark_bootstage,     /* need timer, go after init dm */
#if defined(CONFIG_BOARD_EARLY_INIT_F)
    board_early_init_f,
#endif
    /* TODO: can any of this go into arch_cpu_init()? */
#if defined(CONFIG_PPC) && !defined(CONFIG_8xx_CPUCLK_DEFAULT)
    get_clocks,     /* get CPU and bus clocks (etc.) */
#if defined(CONFIG_TQM8xxL) && !defined(CONFIG_TQM866M) \
        && !defined(CONFIG_TQM885D)
    adjust_sdram_tbs_8xx,
#endif
    /* TODO: can we rename this to timer_init()? */
    init_timebase,
#endif
#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \
        defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \
        defined(CONFIG_SPARC)
    timer_init,     /* initialize timer */
#endif
#ifdef CONFIG_SYS_ALLOC_DPRAM
#if !defined(CONFIG_CPM2)
    dpram_init,
#endif
#endif
#if defined(CONFIG_BOARD_POSTCLK_INIT)
    board_postclk_init,
#endif
#if defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K)
    get_clocks,
#endif
    env_init,       /* initialize environment */
#if defined(CONFIG_8xx_CPUCLK_DEFAULT)
    /* get CPU and bus clocks according to the environment variable */
    get_clocks_866,
    /* adjust sdram refresh rate according to the new clock */
    sdram_adjust_866,
    init_timebase,
#endif
    init_baud_rate,     /* initialze baudrate settings */
    serial_init,        /* serial communications setup */
    console_init_f,     /* stage 1 init of console */
#ifdef CONFIG_SANDBOX
    sandbox_early_getopt_check,
#endif
#ifdef CONFIG_OF_CONTROL
    fdtdec_prepare_fdt,
#endif
    display_options,    /* say that we are here */
    display_text_info,  /* show debugging info if required */
#if defined(CONFIG_MPC8260)
    prt_8260_rsr,
    prt_8260_clks,
#endif /* CONFIG_MPC8260 */
#if defined(CONFIG_MPC83xx)
    prt_83xx_rsr,
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    checkcpu,
#endif
    print_cpuinfo,      /* display cpu info (and speed) */
#if defined(CONFIG_MPC5xxx)
    prt_mpc5xxx_clks,
#endif /* CONFIG_MPC5xxx */
#if defined(CONFIG_DISPLAY_BOARDINFO)
    show_board_info,
#endif
    INIT_FUNC_WATCHDOG_INIT
#if defined(CONFIG_MISC_INIT_F)
    misc_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
    init_func_i2c,
#endif
#if defined(CONFIG_HARD_SPI)
    init_func_spi,
#endif
    announce_dram_init,
    /* TODO: unify all these dram functions? */
#if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \
        defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32)
    dram_init,      /* configure available RAM banks */
#endif
#if defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_M68K)
    init_func_ram,
#endif
#ifdef CONFIG_POST
    post_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_SYS_DRAM_TEST)
    testdram,
#endif /* CONFIG_SYS_DRAM_TEST */
    INIT_FUNC_WATCHDOG_RESET

#ifdef CONFIG_POST
    init_post,
#endif
    INIT_FUNC_WATCHDOG_RESET
    /*
     * Now that we have DRAM mapped and working, we can
     * relocate the code and continue running from DRAM.
     *
     * Reserve memory at end of RAM for (top down in that order):
     *  - area that won't get touched by U-Boot and Linux (optional)
     *  - kernel log buffer
     *  - protected RAM
     *  - LCD framebuffer
     *  - monitor code
     *  - board info struct
     */
    setup_dest_addr,
#if defined(CONFIG_BLACKFIN)
    /* Blackfin u-boot monitor should be on top of the ram */
    reserve_uboot,
#endif
#if defined(CONFIG_SPARC)
    reserve_prom,
#endif
#if defined(CONFIG_LOGBUFFER) && !defined(CONFIG_ALT_LB_ADDR)
    reserve_logbuffer,
#endif
#ifdef CONFIG_PRAM
    reserve_pram,
#endif
    reserve_round_4k,
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF)) && \
        defined(CONFIG_ARM)
    reserve_mmu,
#endif
#ifdef CONFIG_DM_VIDEO
    reserve_video,
#else
# ifdef CONFIG_LCD
    reserve_lcd,
# endif
    /* TODO: Why the dependency on CONFIG_8xx? */
# if defined(CONFIG_VIDEO) && (!defined(CONFIG_PPC) || defined(CONFIG_8xx)) && \
        !defined(CONFIG_ARM) && !defined(CONFIG_X86) && \
        !defined(CONFIG_BLACKFIN) && !defined(CONFIG_M68K)
    reserve_legacy_video,
# endif
#endif /* CONFIG_DM_VIDEO */
    reserve_trace,
#if !defined(CONFIG_BLACKFIN)
    reserve_uboot,
#endif
#ifndef CONFIG_SPL_BUILD
    reserve_malloc,
    reserve_board,
#endif
    setup_machine,
    reserve_global_data,
    reserve_fdt,
    reserve_arch,
    reserve_stacks,
    setup_dram_config,
    show_dram_config,
#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_MIPS)
    setup_board_part1,
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    INIT_FUNC_WATCHDOG_RESET
    setup_board_part2,
#endif
    display_new_sp,
#ifdef CONFIG_SYS_EXTBDINFO
    setup_board_extra,
#endif
    INIT_FUNC_WATCHDOG_RESET
    reloc_fdt,
    setup_reloc,
#if defined(CONFIG_X86) || defined(CONFIG_ARC)
    copy_uboot_to_ram,
    clear_bss,
    do_elf_reloc_fixups,
#endif
#if !defined(CONFIG_ARM) && !defined(CONFIG_SANDBOX)
    jump_to_copy,
#endif
    NULL,
};
```

`init_sequence_f` 因为要支持多种处理器、多种外设、多种配置，所以会很长，但是针对特定的开发板只需要其中的某几个函数即可，而且针对 armv7 需要重点关注的函数有以下几个：

```
serial_init,        /* serial communications setup */
console_init_f,     /* stage 1 init of console */
INIT_FUNC_WATCHDOG_INIT,
INIT_FUNC_WATCHDOG_RESET,
dram_init,      /* configure available RAM banks */
setup_dest_addr,
setup_reloc,
```

其中 `serial_init` ， `console_init_f` ， `dram_init` 是用来配置硬件外设和相关数据结构 ， 如 `serial_init()` 会将外设驱动和 gd 关联起来（`gd->cur_serial_dev = dev;`），以后要使用串口就不需要直接调用具体的外设驱动了。 `setup_dest_addr` 、 `setup_reloc` 、  一起设置 uboot 代码在内存中的位置，为接下来将代码拷贝到内存做准备。

注：ppc 是在 `jump_to_copy` 将代码拷贝到内存的。

执行完 `board_init_f` 配置好相关数据结构、变量后， uboot 会调用 `relocate_code` 进行**重定位代码**，会把代码拷贝到 ddr 内存，然后调用 `board_init_r` 真正的初始化、启动硬件。`board_init_r` 和 `board_init_f` 结构类似，都是执行一连串的初始化函数：

```
void board_init_r(gd_t *new_gd, ulong dest_addr)
{
...
    if (initcall_run_list(init_sequence_r))
        hang();

    /* NOTREACHED - run_main_loop() does not return */
    hang();
}
```


```
 init_fnc_t init_sequence_r[] = {
     initr_trace,
     initr_reloc,
     /* TODO: could x86/PPC have this also perhaps? */
 #ifdef CONFIG_ARM
     initr_caches,
     /* Note: For Freescale LS2 SoCs, new MMU table is created in DDR.
      *   A temporary mapping of IFC high region is since removed,
      *   so environmental variables in NOR flash is not availble
      *   until board_init() is called below to remap IFC to high
      *   region.
      */
 #endif
     initr_reloc_global_data,
 #if defined(CONFIG_SYS_INIT_RAM_LOCK) && defined(CONFIG_E500)
     initr_unlock_ram_in_cache,
 #endif
     initr_barrier,
     initr_malloc,
     initr_console_record,
 #ifdef CONFIG_SYS_NONCACHED_MEMORY
     initr_noncached,
 #endif
     bootstage_relocate,
 #ifdef CONFIG_DM
     initr_dm,
 #endif
     initr_bootstage,
 #if defined(CONFIG_ARM) || defined(CONFIG_NDS32)
     board_init, /* Setup chipselects */
 #endif
     /*
      * TODO: printing of the clock inforamtion of the board is now
      * implemented as part of bdinfo command. Currently only support for
      * davinci SOC's is added. Remove this check once all the board
      * implement this.
      */
 #ifdef CONFIG_CLOCKS
     set_cpu_clk_info, /* Setup clock information */
 #endif
 #ifdef CONFIG_EFI_LOADER
     efi_memory_init,
 #endif
     stdio_init_tables,
     initr_serial,
     initr_announce,
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_NEEDS_MANUAL_RELOC
     initr_manual_reloc_cmdtable,
     initr_manual_reloc_cmdtable,
 #endif
 #if defined(CONFIG_PPC) || defined(CONFIG_M68K)
     initr_trap,
 #endif
 #ifdef CONFIG_ADDR_MAP
     initr_addr_map,
 #endif
 #if defined(CONFIG_BOARD_EARLY_INIT_R)
     board_early_init_r,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_LOGBUFFER
     initr_logbuffer,
 #endif
 #ifdef CONFIG_POST
     initr_post_backlog,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_SYS_DELAYED_ICACHE
     initr_icache_enable,
 #endif
 #if defined(CONFIG_PCI) && defined(CONFIG_SYS_EARLY_PCI_INIT)
     /*
      * Do early PCI configuration _before_ the flash gets initialised,
      * because PCU ressources are crucial for flash access on some boards.
      */
     initr_pci,
 #endif
 #ifdef CONFIG_WINBOND_83C553
     initr_w83c553f,
 #endif
 #ifdef CONFIG_ARCH_EARLY_INIT_R
     arch_early_init_r,
 #endif
     power_init_board,
 #ifndef CONFIG_SYS_NO_FLASH
     initr_flash,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_X86) || \
     defined(CONFIG_SPARC)
     /* initialize higher level parts of CPU like time base and timers */
     cpu_init_r,
 #endif
 #ifdef CONFIG_PPC
     initr_spi,
 #endif
 #ifdef CONFIG_CMD_NAND
     initr_nand,
 #endif
 #ifdef CONFIG_CMD_ONENAND
     initr_onenand,
 #endif
 #ifdef CONFIG_GENERIC_MMC
     initr_mmc,
 #endif
 #ifdef CONFIG_HAS_DATAFLASH
     initr_dataflash,
 #endif
     initr_env,
 #ifdef CONFIG_SYS_BOOTPARAMS_LEN
     initr_malloc_bootparams,
 #endif
     INIT_FUNC_WATCHDOG_RESET
     initr_secondary_cpu,
 #if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)
     mac_read_from_eeprom,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #if defined(CONFIG_PCI) && !defined(CONFIG_SYS_EARLY_PCI_INIT)
     /*
      * Do pci configuration
      */
     initr_pci,
 #endif
     stdio_add_devices,
     initr_jumptable,
 #ifdef CONFIG_API
     initr_api,
 #endif
     console_init_r,     /* fully init console as a device */
 #ifdef CONFIG_DISPLAY_BOARDINFO_LATE
     show_board_info,
 #endif
 #ifdef CONFIG_ARCH_MISC_INIT
     arch_misc_init,     /* miscellaneous arch-dependent init */
 #endif
 #ifdef CONFIG_MISC_INIT_R
     misc_init_r,        /* miscellaneous platform-dependent init */
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_CMD_KGDB
     initr_kgdb,
 #endif
     interrupt_init,
 #if defined(CONFIG_ARM) || defined(CONFIG_AVR32)
     initr_enable_interrupts,
 #endif
 #if defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) || defined(CONFIG_M68K)
     timer_init,     /* initialize timer */
 #endif
 #if defined(CONFIG_STATUS_LED)
     initr_status_led,
 #endif
     /* PPC has a udelay(20) here dating from 2002. Why? */
 #ifdef CONFIG_CMD_NET
     initr_ethaddr,
 #endif
 #ifdef CONFIG_BOARD_LATE_INIT
     board_late_init,
 #endif
 #if defined(CONFIG_CMD_AMBAPP)
     ambapp_init_reloc,
 #if defined(CONFIG_SYS_AMBAPP_PRINT_ON_STARTUP)
     initr_ambapp_print,
 #endif
 #endif
 #ifdef CONFIG_CMD_SCSI
     INIT_FUNC_WATCHDOG_RESET
     initr_scsi,
 #endif
 #ifdef CONFIG_CMD_DOC
     INIT_FUNC_WATCHDOG_RESET
     initr_doc,
 #endif
 #ifdef CONFIG_BITBANGMII
     initr_bbmii,
 #endif
 #ifdef CONFIG_CMD_NET
     INIT_FUNC_WATCHDOG_RESET
     initr_net,
 #endif
 #ifdef CONFIG_POST
     initr_post,
 #endif
 #if defined(CONFIG_CMD_PCMCIA) && !defined(CONFIG_CMD_IDE)
     initr_pcmcia,
 #endif
 #if defined(CONFIG_CMD_IDE)
     initr_ide,
 #endif
 #ifdef CONFIG_LAST_STAGE_INIT
     INIT_FUNC_WATCHDOG_RESET
     /*
      * Some parts can be only initialized if all others (like
      * Interrupts) are up and running (i.e. the PC-style ISA
      * keyboard).
      */
     last_stage_init,
 #endif
 #ifdef CONFIG_CMD_BEDBUG
     INIT_FUNC_WATCHDOG_RESET
     initr_bedbug,
 #endif
 #if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
     initr_mem,
 #endif
 #ifdef CONFIG_PS2KBD
     initr_kbd,
 #endif
 #if defined(CONFIG_SPARC)
     prom_init,
 #endif
     run_main_loop,
 };
```

`init_sequence_r` 也很长，道理同 `init_sequence_f`，这里需要关注的是 `run_main_loop`，进入该函数后，就一路向前进入 uboot 的 shell 和系统引导代码，不在返回汇编了。

```
static int run_main_loop(void)
{
...
    /* main_loop() can return to retry autoboot, if so just run it again */
    for (;;)
        main_loop();
    return 0;
}
```

进入 `main_loop()` 以后，uboot 要么进入 shell 要么直接引导 Linux。

```
/* We come here after U-Boot is initialised and ready to process commands */
void main_loop(void)
{
...
    s = bootdelay_process();
...
    autoboot_command(s);

    cli_loop();
    panic("No CLI available");
}
```

`main_loop()` 首先会等待一段时间检查用户是否有输入（`bootdelay_process()`），要进入 shell ，如果用户没有输入则直接执行默认的启动命令(`autoboot_command`)，否则进入 shell (`cli_loop`)，而 shell 就是个死循环，一直在等待用户输入命令。

注：不同架构处理器的启动代码逻辑（flash->cache->ddr，这三部分）的处理上还是有一些细节差别的。














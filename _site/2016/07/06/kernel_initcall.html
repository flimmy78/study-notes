
<h1 id="initcall">initcall</h1>

<!-- MarkdownTOC -->

<ul>
  <li>
    <ol>
      <li>initcall 定义</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>initcall 的执行</li>
    </ol>
  </li>
</ul>

<!-- /MarkdownTOC -->

<h2 id="initcall-">1. initcall 定义</h2>

<pre><code>#define early_initcall(fn)      __define_initcall(fn, early)
#define pure_initcall(fn)       __define_initcall(fn, 0)

#define core_initcall(fn)       __define_initcall(fn, 1)
#define core_initcall_sync(fn)      __define_initcall(fn, 1s)
#define postcore_initcall(fn)       __define_initcall(fn, 2)
#define postcore_initcall_sync(fn)  __define_initcall(fn, 2s)
#define arch_initcall(fn)       __define_initcall(fn, 3)
#define arch_initcall_sync(fn)      __define_initcall(fn, 3s)
#define subsys_initcall(fn)     __define_initcall(fn, 4)
#define subsys_initcall_sync(fn)    __define_initcall(fn, 4s)
#define fs_initcall(fn)         __define_initcall(fn, 5)
#define fs_initcall_sync(fn)        __define_initcall(fn, 5s)
#define rootfs_initcall(fn)     __define_initcall(fn, rootfs)
#define device_initcall(fn)     __define_initcall(fn, 6)
#define device_initcall_sync(fn)    __define_initcall(fn, 6s)
#define late_initcall(fn)       __define_initcall(fn, 7)
#define late_initcall_sync(fn)      __define_initcall(fn, 7s)
</code></pre>

<p>最终都是通过 <code>__define_initcall</code> 实现的 ：</p>

<pre><code>#define __define_initcall(fn, id) \
    static initcall_t __initcall_##fn##id __used \
    __attribute__((__section__(".initcall" #id ".init"))) = fn
</code></pre>

<p>也就是说经过 <code>*_initcall</code> 修饰的函数最终都会按照顺序放到 section <code>.initcall#id#.init</code> 中，然后kernel 会按照顺序执行这些函数。</p>

<p>而在 <code>include/asm-generic/vmlinux.lds.h</code> 里面已经定义好了对应的 section ：</p>

<pre><code>#define INIT_DATA_SECTION(initsetup_align)              \
    .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) {       \
        INIT_DATA                       \
        INIT_SETUP(initsetup_align)             \
        INIT_CALLS                      \
        CON_INITCALL                        \
        SECURITY_INITCALL                   \
        INIT_RAM_FS                     \
    }
#define VMLINUX_SYMBOL(x) __VMLINUX_SYMBOL(x)

#define INIT_CALLS_LEVEL(level)                     \
        VMLINUX_SYMBOL(__initcall##level##_start) = .;      \
        *(.initcall##level##.init)              \
        *(.initcall##level##s.init)             \

#define INIT_CALLS                          \
        VMLINUX_SYMBOL(__initcall_start) = .;           \
        *(.initcallearly.init)                  \
        INIT_CALLS_LEVEL(0)                 \
        INIT_CALLS_LEVEL(1)                 \
        INIT_CALLS_LEVEL(2)                 \
        INIT_CALLS_LEVEL(3)                 \
        INIT_CALLS_LEVEL(4)                 \
        INIT_CALLS_LEVEL(5)                 \
        INIT_CALLS_LEVEL(rootfs)                \
        INIT_CALLS_LEVEL(6)                 \
        INIT_CALLS_LEVEL(7)                 \
        VMLINUX_SYMBOL(__initcall_end) = .;

</code></pre>

<p>最终编译内核使用 lds 链接脚本 <code>$(arch)/kernel/vmlinux.lds</code> 中就有：</p>

<pre><code>INIT_DATA_SECTION(...)
</code></pre>

<h2 id="initcall--1">2. initcall 的执行</h2>

<p>kernel 启动过程中会执行 <code>init/main.c</code> 的 <code>start_kernel()</code>，然后按照下面的调用链最终会调用 <code>do_initcalls()</code> 执行这些初始化函数：</p>

<p><code>start_kernel()</code>-&gt;<code>rest_init()</code>-&gt;<code>kernel_thread(kernel_init)</code>-&gt;<code>kernel_init_freeable()</code>-&gt;<code>do_basic_setup()</code>-&gt;<code>do_initcalls()</code>-&gt;<code>do_initcall_level()</code></p>

<p>而执行的顺序就跟各个宏的定义有关，比如 <code>pure_initcall</code> 实际上是 <code>__define_initcall(fn, 0)</code> 所以它会被首先执行，而 <code>late_initcall</code> 是 <code>__define_initcall(fn, 7)</code> 所以会最后执行。具体的执行如下：</p>

<pre><code>static void __init do_initcalls(void)
{
    int level;

    for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++)
        do_initcall_level(level);
}
</code></pre>

<p><code>do_initcall_level()</code> 会执行每个 section 内部的所有初始化函数 ：</p>

<pre><code>static void __init do_initcall_level(int level)
{
...
    for (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++)
        do_one_initcall(*fn);
}
</code></pre>

<p><code>do_initcall_level()</code> 按顺序遍历每个 section 执行所有函数。</p>

<p>两个相关的数组，<code>initcall_levels</code> 指向了每个 section 的起始地址，也就是第一个函数地址，<code>initcall_level_names</code> 则将 section 的顺序号（就是 0,1,2,3 这些）和初始化函数的含义关联起来（比如 0 对应 early ，1 对应 core）：</p>

<pre><code>static initcall_t *initcall_levels[] __initdata = {
    __initcall0_start,
    __initcall1_start,
    __initcall2_start,
    __initcall3_start,
    __initcall4_start,
    __initcall5_start,
    __initcall6_start,
    __initcall7_start,
    __initcall_end,
};

/* Keep these in sync with initcalls in include/linux/init.h */
static char *initcall_level_names[] __initdata = {
    "early",
    "core",
    "postcore",
    "arch",
    "subsys",
    "fs",
    "device",
    "late",
};
</code></pre>


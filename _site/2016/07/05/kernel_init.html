
<p>内核启动后从汇编进入 <code>start_kernel()</code> ，然后会调用 <code>rest_init()</code> ，该函数会创建一个内核进程运行 <code>kernel_init()</code> :</p>

<pre><code>static noinline void __init_refok rest_init(void)
{
...
    /*
     * We need to spawn init first so that it obtains pid 1, however
     * the init task will end up wanting to create kthreads, which, if
     * we schedule it before we create kthreadd, will OOPS.
     */
    kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
...
}
</code></pre>

<p><code>kernel_thread()</code> 的原型是 ` pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);` ，创建一个内核线程。</p>

<p><code>kernel_init()</code> 会创建 <code>init</code> 内核线程执行 init 任务：</p>

<pre><code>static int __ref kernel_init(void *unused)
{
    ...
    if (ramdisk_execute_command) {
        if (!run_init_process(ramdisk_execute_command))
            return 0;
        pr_err("Failed to execute %s\n", ramdisk_execute_command);
    }
    if (execute_command) {
        if (!run_init_process(execute_command))
            return 0;
        pr_err("Failed to execute %s.  Attempting defaults...\n", execute_command);
    }
    if (!run_init_process("/sbin/init") ||
        !run_init_process("/etc/init") ||
        !run_init_process("/bin/init") ||
        !run_init_process("/bin/sh"))
        return 0;

    panic("No init found.  Try passing init= option to kernel. "
          "See Linux Documentation/init.txt for guidance.");
}
</code></pre>

<p>内核会根据实际情况、顺序选择执行 <code>ramdisk_execute_command</code> 、 <code>execute_command</code> 、 <code>/sbin/init</code> 、 <code>/etc/init</code> 、 <code>/bin/init</code> 、 <code>/bin/sh</code>，只要一个执行成功就会返回成功，否则进入 <code>panic()</code>。</p>

<p>（未完待续）</p>

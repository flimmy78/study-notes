<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Ezio's Notes</title>
  <meta name="theme-color" content="#222222" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="/study-notes/js/jquery.min.js"></script>
  <script src="/study-notes/js/bootstrap.min.js"></script>
  <script src="/study-notes/js/header.js"></script>
  <script src="/study-notes/js/toc.js"></script>
  <link href="/study-notes/css/bootstrap.min.css" rel="stylesheet">
  <link href="/study-notes/css/theme.css" rel="stylesheet">
  <link href="/study-notes/css/syntax.css" rel="stylesheet">
  <link href="/study-notes/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
</head>

<body>

  

  


 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/study-notes/">Ezio's Notes</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="/study-notes/">/home</a></li>
          <li><a href="/study-notes/archive.html">/archive</a></li>
          <li><a href="/study-notes/tags.html">/tags</a></li>
          <li><a href="/study-notes/about.html">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="/study-notes/2016/07/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E6%9E%90">Linux网络协议栈分析</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>05 Jul 2016</time>
                </div>
                <ul>
                  
                    <li><a href="/study-notes/tags.html#Linux">Linux</a></li>
                  
                    <li><a href="/study-notes/tags.html#Kernel">Kernel</a></li>
                  
                    <li><a href="/study-notes/tags.html#协议栈">协议栈</a></li>
                  
                </ul>
              </div>
              <div class="post-content">
                <div id="toc" class="toc"></div>
                <h1 id="linux-">Linux 网络协议栈</h1>

<!-- MarkdownTOC -->

<ul>
  <li>
    <ol>
      <li>socket 和文件系统都位于 VFS 下一层，对 socket 的操作都要经过 VFS</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>netstack 初始化
        <ul>
          <li>2.1. <code class="highlighter-rouge">sock_init\(\)</code></li>
          <li>2.1. skb</li>
          <li>(skb 待补充)</li>
          <li>2.2. sockfs 初始化</li>
          <li>2.3. 网络协议初始化</li>
          <li>2.4. network namespace subsystem</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<!-- /MarkdownTOC -->

<h2 id="socket--vfs--socket--vfs">1. socket 和文件系统都位于 VFS 下一层，对 socket 的操作都要经过 VFS</h2>

<p><img src="/study-notes/download/sockfs-vfs.jpg" alt="" /></p>

<ul>
  <li>linux 里面每个文件都有唯一的 inode ，inode 会大量使用，为了提高效率会对 inode 进行缓存；</li>
  <li>vfs 要调用具体的文件系统就需要知道每个文件系统的信息，这些信息都放在各自的超级块（super_block) 里，需要文件系统注册（<code class="highlighter-rouge">register_filesystem</code>）把自己挂到 VFS 的 <code class="highlighter-rouge">file_systems</code> 全局链表上，然后通过挂载（<code class="highlighter-rouge">kern_mount</code>）自己、将超级块告知 VFS 。</li>
</ul>

<h2 id="netstack-">2. netstack 初始化</h2>

<p>内核使用 init.h 中定义的初始化宏来进行，即将初始化函数放入特定的代码段去执行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>core_initcall(sock_init);
</code></pre>
</div>

<p>相关的宏和初始化函数还包括</p>

<div class="highlighter-rouge"><pre class="highlight"><code>core_initcall：      sock_init 
fs_initcall：        inet_init 
subsys_initcall：    net_dev_init 
device_initcall:     设备驱动初始化 
</code></pre>
</div>

<p>上面四种宏声明的函数是按顺序执行的。</p>

<h3 id="sockinit">2.1. <code class="highlighter-rouge">sock_init()</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>static int __init sock_init(void)
{
    int err;
    /*
     *      Initialize the network sysctl infrastructure.
     */
    err = net_sysctl_init();
    if (err)
        goto out;

    /*
     *      Initialize skbuff SLAB cache
     */
    skb_init();

    /*
     *      Initialize the protocols module.
     */

    init_inodecache();

    err = register_filesystem(&amp;sock_fs_type);
    if (err)
        goto out_fs;
    sock_mnt = kern_mount(&amp;sock_fs_type);
    if (IS_ERR(sock_mnt)) {
        err = PTR_ERR(sock_mnt);
        goto out_mount;
    }

    /* The real protocol initialization is performed in later initcalls.
     */

#ifdef CONFIG_NETFILTER
    err = netfilter_init();
    if (err)
        goto out;
#endif

#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING
    skb_timestamping_init();
#endif

out:
    return err;

out_mount:
    unregister_filesystem(&amp;sock_fs_type);
out_fs:
    goto out;
}
</code></pre>
</div>

<p><code class="highlighter-rouge">sock_init()</code> 可以分为 4 部分 ： 初始化网络的系统调用（<code class="highlighter-rouge">net_sysctl_init</code>）、初始化 skb 缓存(<code class="highlighter-rouge">skb_init</code>)、初始化 VFS 相关(<code class="highlighter-rouge">init_inodecache</code>、  <code class="highlighter-rouge">register_filesystem</code> 、 <code class="highlighter-rouge">kern_mount</code>)、初始化网络过滤模块（<code class="highlighter-rouge">netfilter_init</code>）。</p>

<h3 id="skb">2.1. skb</h3>
<p>数据包在应用层称为 data，在 TCP 层称为 segment，在 IP 层称为 packet，在数据链路层称为 frame。 Linux 内核中 <code class="highlighter-rouge">sk_buff</code> 结构来存放数据。</p>

<ol>
  <li>sk_buff 结构体</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>struct sk_buff {
    /* These two members must be first. */
    struct sk_buff      *next;
    struct sk_buff      *prev;

    ktime_t         tstamp;

    struct sock     *sk;
    struct net_device   *dev;

    /*
     * This is the control buffer. It is free to use for every
     * layer. Please put your private variables there. If you
     * want to keep them across layers you have to do a skb_clone()
     * first. This is owned by whoever has the skb queued ATM.
     */
#ifdef CONFIG_AS_FASTPATH
    char            cb[96] __aligned(8);
#else
    char            cb[48] __aligned(8);
#endif
    unsigned long       _skb_refdst;
#ifdef CONFIG_XFRM
    struct  sec_path    *sp;
#endif
    unsigned int        len,
                data_len;
    __u16           mac_len,
                hdr_len;
    union {
        __wsum      csum;
        struct {
            __u16   csum_start;
            __u16   csum_offset;
        };
    };
    __u32           priority;
    kmemcheck_bitfield_begin(flags1);
    __u8            local_df:1,
                cloned:1,
                ip_summed:2,
                nohdr:1,
                nfctinfo:3;
    __u8            pkt_type:3,
                fclone:2,
                ipvs_property:1,
                peeked:1,
                nf_trace:1;
    kmemcheck_bitfield_end(flags1);
    __be16          protocol;

    void            (*destructor)(struct sk_buff *skb);
#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
    struct nf_conntrack *nfct;
#endif
#ifdef CONFIG_BRIDGE_NETFILTER
    struct nf_bridge_info   *nf_bridge;
#endif

    int         skb_iif;

    __u32           rxhash;

    __be16          vlan_proto;
    __u16           vlan_tci;

#ifdef CONFIG_NET_SCHED
    __u16           tc_index;   /* traffic control index */
#ifdef CONFIG_NET_CLS_ACT
    __u16           tc_verd;    /* traffic control verdict */
#endif
#endif

    __u16           queue_mapping;
    kmemcheck_bitfield_begin(flags2);
#ifdef CONFIG_IPV6_NDISC_NODETYPE
    __u8            ndisc_nodetype:2;
#endif
    __u8            pfmemalloc:1;
    __u8            ooo_okay:1;
    __u8            l4_rxhash:1;
    __u8            wifi_acked_valid:1;
    __u8            wifi_acked:1;
    __u8            no_fcs:1;
    __u8            head_frag:1;
    /* Encapsulation protocol and NIC drivers should use
     * this flag to indicate to each other if the skb contains
     * encapsulated packet or not and maybe use the inner packet
     * headers if needed
     */
    __u8            encapsulation:1;
    /* 6/8 bit hole (depending on ndisc_nodetype presence) */
    kmemcheck_bitfield_end(flags2);

#if defined CONFIG_NET_DMA || defined CONFIG_NET_RX_BUSY_POLL
    union {
        unsigned int    napi_id;
        dma_cookie_t    dma_cookie;
    };
#endif
#ifdef CONFIG_NETWORK_SECMARK
    __u32           secmark;
#endif
    union {
        __u32       mark;
        __u32       dropcount;
        __u32       reserved_tailroom;
    };

    __be16          inner_protocol;
    __u16           inner_transport_header;
    __u16           inner_network_header;
#if defined(CONFIG_GIANFAR) &amp;&amp; defined(CONFIG_AS_FASTPATH)
    __u8            owner;
    struct sk_buff      *new_skb;
#endif
    __u16           inner_mac_header;
    __u16           transport_header;
    __u16           network_header;
    __u16           mac_header;
    /* These elements must be at the end, see alloc_skb() for details.  */
    sk_buff_data_t      tail;
    sk_buff_data_t      end;
    unsigned char       *head,
                *data;
    unsigned int        truesize;
    atomic_t        users;
};
</code></pre>
</div>

<p>其中几个主要的成员是 ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct sk_buff      *next;      //sk_buff 是以链表组织起来的，需要知道前后两个 sk_buff 的位置
struct sk_buff      *prev;
struct net_device   *dev;       //数据报所属的网络设备
unsigned int        len,        //全部数据的长度
                data_len;       //当前 sk_buff 的分片数据长度
__be16          protocol;       //所属报文的协议类型
__u8            pkt_type:3;     //该数据包的类型
unsigned char   *data;          //保存的数据 
atomic_t        users;          //每引用或“克隆”一次 sk_buff 的时候，都自加 1
</code></pre>
</div>

<p>协议类型</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">宏</th>
      <th style="text-align: left">值</th>
      <th style="text-align: left">说明</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ETH_P_802_2</td>
      <td style="text-align: left">4</td>
      <td style="text-align: left">真正的 802.2 LLC，当报文长度小于 1536 时</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">ETH_P_LOOP</td>
      <td style="text-align: left">0x0060</td>
      <td style="text-align: left">以太网环回报文</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">ETH_P_IP</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">0x0800</td>
      <td>IP 报文</td>
    </tr>
    <tr>
      <td style="text-align: left">ETH_P_ARP</td>
      <td style="text-align: left">0x0806</td>
      <td style="text-align: left">ARP 报文</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">BOND_ETH_P_LACPDU</td>
      <td style="text-align: left">0x8809</td>
      <td style="text-align: left">LACP 协议报文</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">ETH_P_8021Q</td>
      <td style="text-align: left">0x8100</td>
      <td style="text-align: left">VLAN 报文</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">ETH_P_MPLS_UC</td>
      <td style="text-align: left">0x8847</td>
      <td style="text-align: left">MPLS 单播报文</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>数据包类型</p>

<p>宏                      |值      |说明 <br />
:–                     |:–     |:–<br />
PACKET_HOST             |0       |该报文的目的地是本机 <br />
PACKET_BROADCAST        |1       |广播数据包，该 报文的目的地是所有主机<br />
PACKET_MULTICAST        |2       |组播数据包 <br />
PACKET_OTHERHOST        |3       |到其他主机的数据包，在 VLAN 接口接收数据时有用 <br />
PACKET_OUTGOING         |4       |它不是“发送到外部主机的报文”，而是指接收的类型，这<br />
种类型用在 AF_PACKET 的套接字上，这是 Linux 的扩展<br />
PACKET_LOOPBACK         |5       |MC/BRD 的 loopback 帧（用户层不可见）</p>

<ol>
  <li><code class="highlighter-rouge">skb_init()</code></li>
</ol>

<p><code class="highlighter-rouge">skb_init()</code> 创建了两个缓存 <code class="highlighter-rouge">skbuff_head_cache</code> 和 <code class="highlighter-rouge">skbuff_fclone_cache</code> ，协议栈中所使用到的所有的 sk_buff 结构都是从这两个后备高速缓存中分配出来的，两者的区别在于前者是以 <code class="highlighter-rouge">sizeof(struct sk_buff)</code> 为单位创建的，是用来存放单纯的 sk_buff ，后者是以 <code class="highlighter-rouge">2*sizeof(struct sk_buff)+sizeof(atomic_t)</code> 为单位创建的，这一对 sk_buff 是克隆的，即它们指向同一个数据缓冲区，引用计数值是 0，1 或 2， 表示这一对<br />
中有几个 sk_buff 已被使用。</p>

<ol>
  <li>sk_buff 的使用</li>
</ol>

<p>分配 <code class="highlighter-rouge">alloc_skb()</code></p>

<p>销毁 <code class="highlighter-rouge">kfree_skb()</code></p>

<p><strong>分包/组包</strong> ：</p>

<h5 id="skb-">(skb 待补充)</h5>

<h3 id="sockfs-">2.2. sockfs 初始化</h3>

<p>网络通信可以被看作对文件的操作，socket 也是一种文件。网络初始化首先就要初始化 网络文件系统（sockfs）。</p>

<p>第一步是初始化 inode 缓冲(<code class="highlighter-rouge">init_inodecache</code>)，为 sockfs 的 inode 分配一片高速缓存 ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int init_inodecache(void)
{
    sock_inode_cachep = kmem_cache_create("sock_inode_cache",
                          sizeof(struct socket_alloc),
                          0,
                          (SLAB_HWCACHE_ALIGN |
                           SLAB_RECLAIM_ACCOUNT |
                           SLAB_MEM_SPREAD),
                          init_once);
    if (sock_inode_cachep == NULL)
        return -ENOMEM;
    return 0;
}
</code></pre>
</div>

<p>接着注册 sockfs 这种文件系统类型到 VFS 并将 sockfs 注册到 <strong>super_blocks</strong> ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...
init_inodecache();

err = register_filesystem(&amp;sock_fs_type);

sock_mnt = kern_mount(&amp;sock_fs_type);
...
</code></pre>
</div>

<p>这样以后创建 socket 就是在 sockfs 文件系统里创建一个特殊的文件，而文件系统的 <code class="highlighter-rouge">super_block</code> 里面有一个成员变量 <code class="highlighter-rouge">struct super_operations   *s_op;</code> 记录了文件系统支持的操作函数，而这些操作函数都是让 VFS 来调用的，这样一来 socket 的表现就更像一个普通文件，支持大部分操作接口比如 write 、read 、close 等。</p>

<h3 id="section">2.3. 网络协议初始化</h3>

<p>按照上文所述的协议栈初始化顺序， 网络文件系统初始化(<code class="highlighter-rouge">sock_init</code>) 结束之后就开始进入 网络协议初始化(由宏 <code class="highlighter-rouge">fs_initcall</code> 修饰的<code class="highlighter-rouge">inet_init</code>)。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int __init inet_init(void)
{
...
    sysctl_local_reserved_ports = kzalloc(65536 / 8, GFP_KERNEL);
    if (!sysctl_local_reserved_ports)
        goto out;

    rc = proto_register(&amp;tcp_prot, 1);
    if (rc)
        goto out_free_reserved_ports;

    rc = proto_register(&amp;udp_prot, 1);
    if (rc)
        goto out_unregister_tcp_proto;

    rc = proto_register(&amp;raw_prot, 1);
    if (rc)
        goto out_unregister_udp_proto;

    rc = proto_register(&amp;ping_prot, 1);
    if (rc)
        goto out_unregister_raw_proto;

...
    /*
     *  Add all the base protocols.
     */

    if (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; 0)
        pr_crit("%s: Cannot add ICMP protocol\n", __func__);
    if (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0)
        pr_crit("%s: Cannot add UDP protocol\n", __func__);
    if (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; 0)
        pr_crit("%s: Cannot add TCP protocol\n", __func__);
#ifdef CONFIG_IP_MULTICAST
    if (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; 0)
        pr_crit("%s: Cannot add IGMP protocol\n", __func__);
#endif

    /* Register the socket-side information for inet_create. */
    for (r = &amp;inetsw[0]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)
        INIT_LIST_HEAD(r);

    for (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)
        inet_register_protosw(q);

    /*
     *  Set the ARP module up
     */

    arp_init();

    /*
     *  Set the IP module up
     */

    ip_init();

    tcp_v4_init();

    /* Setup TCP slab cache for open requests. */
    tcp_init();

    /* Setup UDP memory threshold */
    udp_init();

    /* Add UDP-Lite (RFC 3828) */
    udplite4_register();

    ping_init();

    /*
     *  Set the ICMP layer up
     */

    if (icmp_init() &lt; 0)
        panic("Failed to create the ICMP control socket.\n");

    /*
     *  Initialise the multicast router
     */
#if defined(CONFIG_IP_MROUTE)
    if (ip_mr_init())
        pr_crit("%s: Cannot init ipv4 mroute\n", __func__);
#endif
    /*
     *  Initialise per-cpu ipv4 mibs
     */

    if (init_ipv4_mibs())
        pr_crit("%s: Cannot init ipv4 mibs\n", __func__);

    ipv4_proc_init();

    ipfrag_init();

    dev_add_pack(&amp;ip_packet_type);

    rc = 0;
...
}
</code></pre>
</div>

<p><code class="highlighter-rouge">inet_init()</code> 主要工作就是注册各种网络协议（如 icmp 、 tcp 、 udp 等）和初始化基础功能模块（如 arp 、 ip 等）。</p>

<ol>
  <li>协议初始化
    <ul>
      <li>ICMP</li>
      <li>UDP</li>
      <li>TCP</li>
      <li>IGMP</li>
    </ul>
  </li>
  <li>模块初始化
    <ul>
      <li>ARP</li>
      <li>ipv4</li>
      <li>tcp/udp/udplite ？</li>
      <li>ping ？</li>
      <li>icmp ？</li>
    </ul>
  </li>
</ol>

<h3 id="network-namespace-subsystem">2.4. network namespace subsystem</h3>


                

              </div>
              
            </div>
            <!-- JiaThis Button BEGIN -->
            <div class="jiathis_style">
                    <span class="jiathis_txt">分享到：</span>
                        <a class="jiathis_button_qzone">QQ空间</a>
                            <a class="jiathis_button_tsina">新浪微博</a>
                                <a class="jiathis_button_tqq">腾讯微博</a>
                                    <a class="jiathis_button_pocket">Pocket</a>
                                        <a class="jiathis_button_evernote">EverNote</a>
                                            <a class="jiathis_button_linkedin">LinkedIn</a>
                                                <a class="jiathis_button_fb">Facebook</a>
                                                    <a class="jiathis_button_weixin">微信</a>
                                                        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
                                                            <a class="jiathis_counter_style"></a>
            </div>
            <script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js" charset="utf-8"></script>
            <!-- JiaThis Button END -->
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/study-notes/2016/07/%E5%BC%80%E5%A7%8B%E8%AE%A4%E7%9C%9F%E5%86%99%E7%AC%94%E8%AE%B0">开始认真写笔记</a></li>
    
    <li><a href="/study-notes/2016/07/%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E7%9A%84initcall">内核启动的initcall</a></li>
    
    <li><a href="/study-notes/2016/07/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E6%9E%90">Linux网络协议栈分析</a></li>
    
    <li><a href="/study-notes/2016/07/kernel%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B">Kernel初始化流程</a></li>
    
    <li><a href="/study-notes/2016/07/linux%E4%B8%8B%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95">Linux下拦截系统调用的一种方法</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Tags</h2>
  <ul>
    
      <li><a href="/study-notes/tag/工具">工具</a></li>
    
      <li><a href="/study-notes/tag/git">git</a></li>
    
      <li><a href="/study-notes/tag/shell">shell</a></li>
    
      <li><a href="/study-notes/tag/vagrant">vagrant</a></li>
    
      <li><a href="/study-notes/tag/ARM">ARM</a></li>
    
      <li><a href="/study-notes/tag/开发板">开发板</a></li>
    
      <li><a href="/study-notes/tag/beaglebone">beaglebone</a></li>
    
      <li><a href="/study-notes/tag/PPC">PPC</a></li>
    
      <li><a href="/study-notes/tag/android">android</a></li>
    
      <li><a href="/study-notes/tag/Knowledge">Knowledge</a></li>
    
      <li><a href="/study-notes/tag/个人">个人</a></li>
    
      <li><a href="/study-notes/tag/C/C++">C/C++</a></li>
    
      <li><a href="/study-notes/tag/Linux">Linux</a></li>
    
      <li><a href="/study-notes/tag/net">net</a></li>
    
      <li><a href="/study-notes/tag/RaspberryPi">RaspberryPi</a></li>
    
      <li><a href="/study-notes/tag/RTOS">RTOS</a></li>
    
      <li><a href="/study-notes/tag/u-boot">u-boot</a></li>
    
      <li><a href="/study-notes/tag/文件系统">文件系统</a></li>
    
      <li><a href="/study-notes/tag/协议栈">协议栈</a></li>
    
      <li><a href="/study-notes/tag/驱动">驱动</a></li>
    
      <li><a href="/study-notes/tag/Kernel">Kernel</a></li>
    
  </ul>
</div>

        </div>
      </div>
    </div>
    

  </div>

      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Ezio &copy; 2016</p>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="oska874 on Github" href="https://github.com/oska874" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="1294322 on StackOverflow" href="http://stackoverflow.com/users/1294322" target="_blank"><i class="fa fa-stack-overflow fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="oska874 on LinkedIn" href="https://www.linkedin.com/in/zhang-lei-1b41b669" target="_blank"><i class="fa fa-linkedin fa-2x"></i></a>
    </li>
  

  

  

  
    <li>
      <a title="feed.xml RSS" href="/study-notes/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>
  </body>
</html>

</div>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Blog Name</title>
  <meta name="theme-color" content="#222222" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/header.js"></script>
  <script src="/js/toc.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/theme.css" rel="stylesheet">
  <link href="/css/syntax.css" rel="stylesheet">
  <link href="/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
</head>

<body>

  

  


 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">Blog Name</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="/">/home</a></li>
          <li><a href="/archive.html">/archive</a></li>
          <li><a href="/tags.html">/tags</a></li>
          <li><a href="/about.html">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="/2016/07/uboot-net">Uboot Net</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>03 Jul 2016</time>
                </div>
                <ul>
                  
                </ul>
              </div>
              <div class="post-content">
                <div id="toc" class="toc"></div>
                
<h1 id="section">网络协议栈</h1>

<!-- MarkdownTOC -->

<ul>
  <li>
    <ol>
      <li>net
        <ul>
          <li>7.1. 协议栈主循环</li>
          <li>7.2. 协议栈和驱动</li>
          <li>7.3. ping</li>
          <li>7.4. tftp</li>
          <li>7.5. 小结</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<!-- /MarkdownTOC -->

<h2 id="net">7. net</h2>

<p>uboot 支持 tcp/ip 网络协议，但是作为一个 bootloader 它并没有把协议栈作为一个后台线程长时间运行，而是在使用到网络功能时才会初始化协议栈、使用网络功能。</p>

<h3 id="section-1">7.1. 协议栈主循环</h3>

<p><code class="highlighter-rouge">net_loop</code>（<code class="highlighter-rouge">net/net.c</code>） 是网络协议栈的主循环，所有的网络操作最终都会进入这里。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int net_loop(enum proto_t protocol)
{
   ...
    if (eth_is_on_demand_init() || protocol != NETCONS) {
        eth_halt();
        eth_set_current();
        ret = eth_init();
        if (ret &lt; 0) {
            eth_halt();
            return ret;
        }
    } else {
        eth_init_state_only();
    }
restart:
...
    switch (net_check_prereq(protocol)) {
    case 1:
        /* network not configured */
        eth_halt();
        return -ENODEV;

    case 2:
        /* network device not configured */
        break;

    case 0:
        net_dev_exists = 1;
        net_boot_file_size = 0;
        switch (protocol) {
        case TFTPGET:
#ifdef CONFIG_CMD_TFTPPUT
        case TFTPPUT:
#endif
            /* always use ARP to get server ethernet address */
            tftp_start(protocol);
            break;
#ifdef CONFIG_CMD_TFTPSRV
        case TFTPSRV:
            tftp_start_server();
            break;
#endif
#if defined(CONFIG_CMD_DHCP)
        case DHCP:
            bootp_reset();
            net_ip.s_addr = 0;
            dhcp_request();     /* Basically same as BOOTP */
            break;
#endif

        case BOOTP:
            bootp_reset();
            net_ip.s_addr = 0;
            bootp_request();
            break;

#if defined(CONFIG_CMD_RARP)
        case RARP:
            rarp_try = 0;
            net_ip.s_addr = 0;
            rarp_request();
            break;
#endif
#if defined(CONFIG_CMD_PING)
        case PING:
            ping_start();
            break;
#endif
#if defined(CONFIG_CMD_NFS)
        case NFS:
            nfs_start();
            break;
#endif
#if defined(CONFIG_CMD_CDP)
        case CDP:
            cdp_start();
            break;
#endif
#if defined(CONFIG_NETCONSOLE) &amp;&amp; !(CONFIG_SPL_BUILD)
        case NETCONS:
            nc_start();
            break;
#endif
#if defined(CONFIG_CMD_SNTP)
        case SNTP:
            sntp_start();
            break;
#endif
#if defined(CONFIG_CMD_DNS)
        case DNS:
            dns_start();
            break;
#endif
#if defined(CONFIG_CMD_LINK_LOCAL)
        case LINKLOCAL:
            link_local_start();
            break;
#endif
        default:
            break;
        }

        break;
    }

#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
#if defined(CONFIG_SYS_FAULT_ECHO_LINK_DOWN)    &amp;&amp; \
    defined(CONFIG_STATUS_LED)          &amp;&amp; \
    defined(STATUS_LED_RED)
    /*
     * Echo the inverted link state to the fault LED.
     */
    if (miiphy_link(eth_get_dev()-&gt;name, CONFIG_SYS_FAULT_MII_ADDR))
        status_led_set(STATUS_LED_RED, STATUS_LED_OFF);
    else
        status_led_set(STATUS_LED_RED, STATUS_LED_ON);
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
#ifdef CONFIG_USB_KEYBOARD
    net_busy_flag = 1;
#endif

    /*
     *  Main packet reception loop.  Loop receiving packets until
     *  someone sets `net_state' to a state that terminates.
     */
    for (;;) {
        WATCHDOG_RESET();
#ifdef CONFIG_SHOW_ACTIVITY
        show_activity(1);
#endif
        if (arp_timeout_check() &gt; 0)
            time_start = get_timer(0);

        /*
         *  Check the ethernet for a new packet.  The ethernet
         *  receive routine will process it.
         *  Most drivers return the most recent packet size, but not
         *  errors that may have happened.
         */
        eth_rx();

        /*
         *  Abort if ctrl-c was pressed.
         */
        if (ctrlc()) {
            /* cancel any ARP that may not have completed */
            net_arp_wait_packet_ip.s_addr = 0;

            net_cleanup_loop();
            eth_halt();
            /* Invalidate the last protocol */
            eth_set_last_protocol(BOOTP);

            puts("\nAbort\n");
            /* include a debug print as well incase the debug
               messages are directed to stderr */
            debug_cond(DEBUG_INT_STATE, "--- net_loop Abort!\n");
            ret = -EINTR;
            goto done;
        }

        /*
         *  Check for a timeout, and run the timeout handler
         *  if we have one.
         */
        if (time_handler &amp;&amp;
            ((get_timer(0) - time_start) &gt; time_delta)) {
            thand_f *x;

#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
#if defined(CONFIG_SYS_FAULT_ECHO_LINK_DOWN)    &amp;&amp; \
    defined(CONFIG_STATUS_LED)          &amp;&amp; \
    defined(STATUS_LED_RED)
            /*
             * Echo the inverted link state to the fault LED.
             */
            if (miiphy_link(eth_get_dev()-&gt;name,
                    CONFIG_SYS_FAULT_MII_ADDR))
                status_led_set(STATUS_LED_RED, STATUS_LED_OFF);
            else
                status_led_set(STATUS_LED_RED, STATUS_LED_ON);
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
            debug_cond(DEBUG_INT_STATE, "--- net_loop timeout\n");
            x = time_handler;
            time_handler = (thand_f *)0;
            (*x)();
        }

        if (net_state == NETLOOP_FAIL)
            ret = net_start_again();

        switch (net_state) {
        case NETLOOP_RESTART:
            net_restarted = 1;
            goto restart;

        case NETLOOP_SUCCESS:
            net_cleanup_loop();
            if (net_boot_file_size &gt; 0) {
                printf("Bytes transferred = %d (%x hex)\n",
                       net_boot_file_size, net_boot_file_size);
                setenv_hex("filesize", net_boot_file_size);
                setenv_hex("fileaddr", load_addr);
            }
            if (protocol != NETCONS)
                eth_halt();
            else
                eth_halt_state_only();

            eth_set_last_protocol(protocol);

            ret = net_boot_file_size;
            debug_cond(DEBUG_INT_STATE, "--- net_loop Success!\n");
            goto done;

        case NETLOOP_FAIL:
            net_cleanup_loop();
            /* Invalidate the last protocol */
            eth_set_last_protocol(BOOTP);
            debug_cond(DEBUG_INT_STATE, "--- net_loop Fail!\n");
            goto done;

        case NETLOOP_CONTINUE:
            continue;
        }
    }

done:
#ifdef CONFIG_USB_KEYBOARD
    net_busy_flag = 0;
#endif
#ifdef CONFIG_CMD_TFTPPUT
    /* Clear out the handlers */
    net_set_udp_handler(NULL);
    net_set_icmp_handler(NULL);
#endif
    return ret;
}
</code></pre>
</div>

<p>从上面的代码可以看出 <br />
uboot 网络处里流程和一般的协议栈类似（如 lwip 所有的操作都是放在一个循环，在一个线程中运行）。</p>

<p>流程可以分解为 3 步：</p>

<ol>
  <li>初始化协议栈<br />
<code class="highlighter-rouge">
net_init();
net_init_loop();
</code></li>
  <li>区分不同的子协议（如 ping 、 ICMP 、 arp 等）<br />
<code class="highlighter-rouge">
case DHCP:
 ...
case PING:
 ...
case DNS:
 ...
...
</code></li>
  <li>关闭协议栈和网络设备<br />
<code class="highlighter-rouge">
...
eth_halt();
...
net_cleanup_loop();
...
</code></li>
</ol>

<h3 id="section-2">7.2. 协议栈和驱动</h3>

<p>协议栈收发数据都是通过函数 <code class="highlighter-rouge">eth_send()</code> 和 <code class="highlighter-rouge">eth_rx()</code> 完成的。</p>

<p>发包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int eth_send(void *packet, int length)                         
{                                                              
...                                   
    current = eth_get_dev();                                   
...
    ret = eth_get_ops(current)-&gt;send(current, packet, length); 
    if (ret &lt; 0) {                                             
        /* We cannot completely return the error at present */ 
        debug("%s: send() returned error %d\n", __func__, ret);
    }                                                          
    return ret;                                                
}                                                              

</code></pre>
</div>

<p>收包：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int eth_rx(void)
{
...
    current = eth_get_dev();
...  
    for (i = 0; i &lt; 32; i++) {
        ret = eth_get_ops(current)-&gt;recv(current, flags, &amp;packet);
        flags = 0;
        if (ret &gt; 0)
            net_process_received_packet(packet, ret);
        if (ret &gt;= 0 &amp;&amp; eth_get_ops(current)-&gt;free_pkt)
            eth_get_ops(current)-&gt;free_pkt(current, packet, ret);
        if (ret &lt;= 0)
            break;
    }
...
    return ret;
}
</code></pre>
</div>

<p>两者最终都是调用实际的驱动函数 <code class="highlighter-rouge">cpsw_send()</code> 和 <code class="highlighter-rouge">cpsw_recv()</code> 进行收发包</p>

<h3 id="ping">7.3. ping</h3>

<p>uboot 网络支持多种操作，但是都有一个特点就是必须 uboot 首先发起操作，然后相应对端的操作，并不能像一般的系统那样时时刻刻接受对端的网络请求。</p>

<p>ping 的实现也只是向外发送 ping 包，然后接收响应，并不会响应对端发起的 ping 操作。</p>

<p>ping 是作为一个命令（<code class="highlighter-rouge">ping</code>）存在于 uboot 的，它的函数实现是 <code class="highlighter-rouge">do_ping()</code>（<code class="highlighter-rouge">cmd/net.c</code>） ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int do_ping(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
...
    if (net_loop(PING) &lt; 0) {
        printf("ping failed; host %s is not alive\n", argv[1]);
        return CMD_RET_FAILURE;
    }
...
}
</code></pre>
</div>

<p>然后进入 <code class="highlighter-rouge">net_loop()</code>  ，首先向外发 ping 包 ：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...
switch (protocol) {
    ...
    case PING:
        ping_start();
        break;
    ...
}
</code></pre>
</div>

<p>调用 ping 的发包函数<br />
```<br />
void ping_start(void)<br />
{<br />
    printf(“Using %s device\n”, eth_get_name());<br />
    net_set_timeout_handler(10000UL, ping_timeout_handler);</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ping_send(); } ```
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>static int ping_send(void)
{
...
    arp_request();
    return 1;   /* waiting */
}
</code></pre>
</div>

<p><code class="highlighter-rouge">arp_request()</code> 最终会执行 <code class="highlighter-rouge">eth_send()</code> 调用网卡驱动发送数据包。</p>

<p>接下来，<code class="highlighter-rouge">net_loop()</code> 会等待对端发送的响应包，并进行处理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for (;;) {
    ...
    eth_rx();
    ...
}
</code></pre>
</div>

<p><code class="highlighter-rouge">eth_rx()</code> 调用网卡驱动，而网卡驱动会调用函数 <code class="highlighter-rouge">net_process_received_packet()</code> 处理协议栈相关的操作，此处就是执行 <code class="highlighter-rouge">ping_receive()</code> 完成 ping 操作的<strong>收</strong>阶段：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
    struct icmp_hdr *icmph = (struct icmp_hdr *)&amp;ip-&gt;udp_src;
    struct in_addr src_ip;
    int eth_hdr_size;

    switch (icmph-&gt;type) {
    case ICMP_ECHO_REPLY:
        src_ip = net_read_ip((void *)&amp;ip-&gt;ip_src);
        if (src_ip.s_addr == net_ping_ip.s_addr)
            net_set_state(NETLOOP_SUCCESS);
        return;
    ...
/*  default:
        return;*/
    }
}
</code></pre>
</div>

<p>通过函数 <code class="highlighter-rouge">net_set_state()</code> 告知 <code class="highlighter-rouge">net_loop()</code> ping 操作成功，否则 ping 失败，即网络有问题。</p>

<h3 id="tftp">7.4. tftp</h3>

<p>tftp 分两部分：向服务器发送请求和从服务器接收数据，所以在 <code class="highlighter-rouge">net_loop()</code> 中 tftp 协议有两组判断条件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int net_loop(enum proto_t protocol)
{
    ...
        case TFTPGET:
#ifdef CONFIG_CMD_TFTPPUT
        case TFTPPUT:
#endif
            /* always use ARP to get server ethernet address */
            tftp_start(protocol);
            break;
    ...

}
</code></pre>
</div>

<p>发送请求（<code class="highlighter-rouge">TFTPGET</code> 和 <code class="highlighter-rouge">TFTPPUT</code>），向对端发送 tftp 请求，比如 GET 和 PUT ，调用 <code class="highlighter-rouge">tftp_start()</code> 发送请求报文：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void tftp_start(enum proto_t protocol)
{
...
    net_set_udp_handler(tftp_handler);
...
    tftp_send();
...
}
</code></pre>
</div>

<p>其中 <code class="highlighter-rouge">net_set_udp_handler()</code> 会注册 <code class="highlighter-rouge">tftp_handler()</code> 到钩子函数 <code class="highlighter-rouge">static rxhand_f *udp_packet_handler;</code>，而 <code class="highlighter-rouge">tftp_handler()</code> 会调用 <code class="highlighter-rouge">tftp_complete()</code> 检查接收文件是否结束。</p>

<p>接下来 <code class="highlighter-rouge">net_loop()</code> 会循环调用 <code class="highlighter-rouge">eth_rx()</code> 接收数据包，直到所有数据都收完（钩子函数 <code class="highlighter-rouge">udp_packet_handler</code> 会不断的检查已收到的文件长度和实际文件长度是否一直）。</p>

<h3 id="section-3">7.5. 小结</h3>

<p>uboot 的网络协议栈可以说是麻雀虽小肝胆俱全，网络协议栈所需要的功能它基本都实现了，比如 ping 、 tftp 、tftp server 、DHCP 、 bootp 、 arp/rarp 、DNS 等，它主要侧重于功能的实现，对实时性、并发性等要求不高，所以都是由用户输入命令主动发起操作，并且是单线程操作。</p>


                

              </div>
              
            </div>
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/2016/07/kernel_initcall">Kernel_initcall</a></li>
    
    <li><a href="/2016/07/linux_netstack">Linux_netstack</a></li>
    
    <li><a href="/2016/07/kernel_init">Kernel_init</a></li>
    
    <li><a href="/2016/07/intercept_syscall">Intercept_syscall</a></li>
    
    <li><a href="/2016/07/uboot-net">Uboot Net</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Tags</h2>
  <ul>
    
  </ul>
</div>

        </div>
      </div>
    </div>
    

  </div>
      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Pavel Makhov &copy; 2015</p>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="streetturtle on Github" href="https://github.com/streetturtle" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title=" on StackOverflow" href="http://stackoverflow.com/users/" target="_blank"><i class="fa fa-stack-overflow fa-2x"></i></a>
    </li>
  

  

  
    <li>
      <a title=" on Instagram" href="https://instagram.com/" target="_blank"><i class="fa fa-instagram fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title=" on Last.fm" href="http://lastfm.com/user/" target="_blank"><i class="fa fa-lastfm fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="feed.xml RSS" href="/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>
  </body>
</html>

</div>

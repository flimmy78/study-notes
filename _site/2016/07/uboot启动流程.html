<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Ezio's Notes</title>
  <meta name="theme-color" content="#222222" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="/study-notes/js/jquery.min.js"></script>
  <script src="/study-notes/js/bootstrap.min.js"></script>
  <script src="/study-notes/js/header.js"></script>
  <script src="/study-notes/js/toc.js"></script>
  <link href="/study-notes/css/bootstrap.min.css" rel="stylesheet">
  <link href="/study-notes/css/theme.css" rel="stylesheet">
  <link href="/study-notes/css/syntax.css" rel="stylesheet">
  <link href="/study-notes/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
</head>

<body>

  

  


 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/study-notes/">Ezio's Notes</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="/study-notes/">/home</a></li>
          <li><a href="/study-notes/archive.html">/archive</a></li>
          <li><a href="/study-notes/tags.html">/tags</a></li>
          <li><a href="/study-notes/about.html">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="/study-notes/2016/07/uboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">Uboot启动流程</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>02 Jul 2016</time>
                </div>
                <ul>
                  
                    <li><a href="/study-notes/tags.html#u-boot">u-boot</a></li>
                  
                </ul>
              </div>
              <div class="post-content">
                <div id="toc" class="toc"></div>
                <h1 id="startup">startup</h1>

<h2 id="startup-1">7. startup</h2>

<ol>
  <li>armv7</li>
</ol>

<p>CPU 上电自动进入默认的 reset 中断向量入口，开始执行 uboot 启动汇编(<code class="highlighter-rouge">arch/arm/cpu/armv7/start.S</code>)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/*************************************************************************
 *
 * Startup Code (reset vector)
 *
 * Do important init only if we don't start from memory!
 * Setup memory and board specific bits prior to relocation.
 * Relocate armboot to ram. Setup stack.
 *
 *************************************************************************/

    .globl  reset
    .globl  save_boot_params_ret

reset:
    /* Allow the board to save important registers */
    b   save_boot_params
</code></pre>
</div>

<p>接下来关中断进入 SVC 模式，设置自己的中断向量表地址（将地址写到 SCTLR 寄存器），初始化 CPU (根据实际不同处理器需求)，然后进入 C 运行时代码（<code class="highlighter-rouge">bl _main</code>）。</p>

<p><code class="highlighter-rouge">_main</code> 位于 <code class="highlighter-rouge">arch/arm/lib/crt0.S</code> ，此处代码是独立于硬件的，主要用来初始化硬件配置和为接下来的 C 语言提供运行环境（提供 stack 环境等），最终进入 uboot 的主循环。</p>

<div class="highlighter-rouge"><pre class="highlight"><code> /*
  * entry point of crt0 sequence
  */

 ENTRY(_main)

...
 ldr sp, =(CONFIG_SYS_INIT_SP_ADDR)     /*配置 stack*/ 
...
 bl  board_init_f_init_reserve           /*初始化 gd 结构体*/    
...
 bl  board_init_f                        /* 初始化外设和相关数据结构*/
...
 ldr r0, =__bss_start    /* this is auto-relocated! */
 ldr r1, =__bss_end      /* this is auto-relocated! */
 mov r2, #0x00000000     /* prepare zero to clear BSS */
...
 b   relocate_code      /* 将代码拷贝到 ddr*/
...
    /* call board_init_r(gd_t *id, ulong dest_addr) */
    mov     r0, r9                  /* gd_t */
    ldr r1, [r9, #GD_RELOCADDR] /* dest_addr */
    /* call board_init_r */
    ldr pc, =board_init_r   /* this is auto-relocated! */
...
 ENDPROC(_main)
</code></pre>
</div>

<p>注： 有的开发板的 uboot 会要求生成两个 bin 文件 ： u-boot.bin 和 u-boot-spl.bin，此处先只讨论 u-boot.bin。</p>

<p>进入 <code class="highlighter-rouge">board_init_f()</code> 后会分步骤的初始化外设、将代码拷贝到 DDR 内存。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void board_init_f(ulong boot_flags)
{
...
    if (initcall_run_list(init_sequence_f))
        hang();       
...
}
</code></pre>
</div>

<p><code class="highlighter-rouge">initcall_run_list()</code> 用来执行结构体数组 <code class="highlighter-rouge">init_sequence_f</code> 定义的一系列配置初始化函数，而 <code class="highlighter-rouge">init_sequence_f</code> 包含的初始化函数如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static init_fnc_t init_sequence_f[] = {
#ifdef CONFIG_SANDBOX
    setup_ram_buf,
#endif
    setup_mon_len,
#ifdef CONFIG_OF_CONTROL
    fdtdec_setup,
#endif
#ifdef CONFIG_TRACE
    trace_early_init,
#endif
    initf_malloc,
    initf_console_record,
#if defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)
    /* TODO: can this go into arch_cpu_init()? */
    probecpu,
#endif
#if defined(CONFIG_X86) &amp;&amp; defined(CONFIG_HAVE_FSP)
    x86_fsp_init,
#endif
    arch_cpu_init,      /* basic arch cpu dependent setup */
    initf_dm,
    arch_cpu_init_dm,
    mark_bootstage,     /* need timer, go after init dm */
#if defined(CONFIG_BOARD_EARLY_INIT_F)
    board_early_init_f,
#endif
    /* TODO: can any of this go into arch_cpu_init()? */
#if defined(CONFIG_PPC) &amp;&amp; !defined(CONFIG_8xx_CPUCLK_DEFAULT)
    get_clocks,     /* get CPU and bus clocks (etc.) */
#if defined(CONFIG_TQM8xxL) &amp;&amp; !defined(CONFIG_TQM866M) \
        &amp;&amp; !defined(CONFIG_TQM885D)
    adjust_sdram_tbs_8xx,
#endif
    /* TODO: can we rename this to timer_init()? */
    init_timebase,
#endif
#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \
        defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \
        defined(CONFIG_SPARC)
    timer_init,     /* initialize timer */
#endif
#ifdef CONFIG_SYS_ALLOC_DPRAM
#if !defined(CONFIG_CPM2)
    dpram_init,
#endif
#endif
#if defined(CONFIG_BOARD_POSTCLK_INIT)
    board_postclk_init,
#endif
#if defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K)
    get_clocks,
#endif
    env_init,       /* initialize environment */
#if defined(CONFIG_8xx_CPUCLK_DEFAULT)
    /* get CPU and bus clocks according to the environment variable */
    get_clocks_866,
    /* adjust sdram refresh rate according to the new clock */
    sdram_adjust_866,
    init_timebase,
#endif
    init_baud_rate,     /* initialze baudrate settings */
    serial_init,        /* serial communications setup */
    console_init_f,     /* stage 1 init of console */
#ifdef CONFIG_SANDBOX
    sandbox_early_getopt_check,
#endif
#ifdef CONFIG_OF_CONTROL
    fdtdec_prepare_fdt,
#endif
    display_options,    /* say that we are here */
    display_text_info,  /* show debugging info if required */
#if defined(CONFIG_MPC8260)
    prt_8260_rsr,
    prt_8260_clks,
#endif /* CONFIG_MPC8260 */
#if defined(CONFIG_MPC83xx)
    prt_83xx_rsr,
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    checkcpu,
#endif
    print_cpuinfo,      /* display cpu info (and speed) */
#if defined(CONFIG_MPC5xxx)
    prt_mpc5xxx_clks,
#endif /* CONFIG_MPC5xxx */
#if defined(CONFIG_DISPLAY_BOARDINFO)
    show_board_info,
#endif
    INIT_FUNC_WATCHDOG_INIT
#if defined(CONFIG_MISC_INIT_F)
    misc_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
    init_func_i2c,
#endif
#if defined(CONFIG_HARD_SPI)
    init_func_spi,
#endif
    announce_dram_init,
    /* TODO: unify all these dram functions? */
#if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \
        defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32)
    dram_init,      /* configure available RAM banks */
#endif
#if defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_M68K)
    init_func_ram,
#endif
#ifdef CONFIG_POST
    post_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_SYS_DRAM_TEST)
    testdram,
#endif /* CONFIG_SYS_DRAM_TEST */
    INIT_FUNC_WATCHDOG_RESET

#ifdef CONFIG_POST
    init_post,
#endif
    INIT_FUNC_WATCHDOG_RESET
    /*
     * Now that we have DRAM mapped and working, we can
     * relocate the code and continue running from DRAM.
     *
     * Reserve memory at end of RAM for (top down in that order):
     *  - area that won't get touched by U-Boot and Linux (optional)
     *  - kernel log buffer
     *  - protected RAM
     *  - LCD framebuffer
     *  - monitor code
     *  - board info struct
     */
    setup_dest_addr,
#if defined(CONFIG_BLACKFIN)
    /* Blackfin u-boot monitor should be on top of the ram */
    reserve_uboot,
#endif
#if defined(CONFIG_SPARC)
    reserve_prom,
#endif
#if defined(CONFIG_LOGBUFFER) &amp;&amp; !defined(CONFIG_ALT_LB_ADDR)
    reserve_logbuffer,
#endif
#ifdef CONFIG_PRAM
    reserve_pram,
#endif
    reserve_round_4k,
#if !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF)) &amp;&amp; \
        defined(CONFIG_ARM)
    reserve_mmu,
#endif
#ifdef CONFIG_DM_VIDEO
    reserve_video,
#else
# ifdef CONFIG_LCD
    reserve_lcd,
# endif
    /* TODO: Why the dependency on CONFIG_8xx? */
# if defined(CONFIG_VIDEO) &amp;&amp; (!defined(CONFIG_PPC) || defined(CONFIG_8xx)) &amp;&amp; \
        !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_X86) &amp;&amp; \
        !defined(CONFIG_BLACKFIN) &amp;&amp; !defined(CONFIG_M68K)
    reserve_legacy_video,
# endif
#endif /* CONFIG_DM_VIDEO */
    reserve_trace,
#if !defined(CONFIG_BLACKFIN)
    reserve_uboot,
#endif
#ifndef CONFIG_SPL_BUILD
    reserve_malloc,
    reserve_board,
#endif
    setup_machine,
    reserve_global_data,
    reserve_fdt,
    reserve_arch,
    reserve_stacks,
    setup_dram_config,
    show_dram_config,
#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_MIPS)
    setup_board_part1,
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    INIT_FUNC_WATCHDOG_RESET
    setup_board_part2,
#endif
    display_new_sp,
#ifdef CONFIG_SYS_EXTBDINFO
    setup_board_extra,
#endif
    INIT_FUNC_WATCHDOG_RESET
    reloc_fdt,
    setup_reloc,
#if defined(CONFIG_X86) || defined(CONFIG_ARC)
    copy_uboot_to_ram,
    clear_bss,
    do_elf_reloc_fixups,
#endif
#if !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX)
    jump_to_copy,
#endif
    NULL,
};
</code></pre>
</div>

<p><code class="highlighter-rouge">init_sequence_f</code> 因为要支持多种处理器、多种外设、多种配置，所以会很长，但是针对特定的开发板只需要其中的某几个函数即可，而且针对 armv7 需要重点关注的函数有以下几个：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>serial_init,        /* serial communications setup */
console_init_f,     /* stage 1 init of console */
INIT_FUNC_WATCHDOG_INIT,
INIT_FUNC_WATCHDOG_RESET,
dram_init,      /* configure available RAM banks */
setup_dest_addr,
setup_reloc,
</code></pre>
</div>

<p>其中 <code class="highlighter-rouge">serial_init</code> ， <code class="highlighter-rouge">console_init_f</code> ， <code class="highlighter-rouge">dram_init</code> 是用来配置硬件外设和相关数据结构 ， 如 <code class="highlighter-rouge">serial_init()</code> 会将外设驱动和 gd 关联起来（<code class="highlighter-rouge">gd-&gt;cur_serial_dev = dev;</code>），以后要使用串口就不需要直接调用具体的外设驱动了。 <code class="highlighter-rouge">setup_dest_addr</code> 、 <code class="highlighter-rouge">setup_reloc</code> 、  一起设置 uboot 代码在内存中的位置，为接下来将代码拷贝到内存做准备。</p>

<p>注：ppc 是在 <code class="highlighter-rouge">jump_to_copy</code> 将代码拷贝到内存的。</p>

<p>执行完 <code class="highlighter-rouge">board_init_f</code> 配置好相关数据结构、变量后， uboot 会调用 <code class="highlighter-rouge">relocate_code</code> 进行<strong>重定位代码</strong>，会把代码拷贝到 ddr 内存，然后调用 <code class="highlighter-rouge">board_init_r</code> 真正的初始化、启动硬件。<code class="highlighter-rouge">board_init_r</code> 和 <code class="highlighter-rouge">board_init_f</code> 结构类似，都是执行一连串的初始化函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void board_init_r(gd_t *new_gd, ulong dest_addr)
{
...
    if (initcall_run_list(init_sequence_r))
        hang();

    /* NOTREACHED - run_main_loop() does not return */
    hang();
}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code> init_fnc_t init_sequence_r[] = {
     initr_trace,
     initr_reloc,
     /* TODO: could x86/PPC have this also perhaps? */
 #ifdef CONFIG_ARM
     initr_caches,
     /* Note: For Freescale LS2 SoCs, new MMU table is created in DDR.
      *   A temporary mapping of IFC high region is since removed,
      *   so environmental variables in NOR flash is not availble
      *   until board_init() is called below to remap IFC to high
      *   region.
      */
 #endif
     initr_reloc_global_data,
 #if defined(CONFIG_SYS_INIT_RAM_LOCK) &amp;&amp; defined(CONFIG_E500)
     initr_unlock_ram_in_cache,
 #endif
     initr_barrier,
     initr_malloc,
     initr_console_record,
 #ifdef CONFIG_SYS_NONCACHED_MEMORY
     initr_noncached,
 #endif
     bootstage_relocate,
 #ifdef CONFIG_DM
     initr_dm,
 #endif
     initr_bootstage,
 #if defined(CONFIG_ARM) || defined(CONFIG_NDS32)
     board_init, /* Setup chipselects */
 #endif
     /*
      * TODO: printing of the clock inforamtion of the board is now
      * implemented as part of bdinfo command. Currently only support for
      * davinci SOC's is added. Remove this check once all the board
      * implement this.
      */
 #ifdef CONFIG_CLOCKS
     set_cpu_clk_info, /* Setup clock information */
 #endif
 #ifdef CONFIG_EFI_LOADER
     efi_memory_init,
 #endif
     stdio_init_tables,
     initr_serial,
     initr_announce,
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_NEEDS_MANUAL_RELOC
     initr_manual_reloc_cmdtable,
     initr_manual_reloc_cmdtable,
 #endif
 #if defined(CONFIG_PPC) || defined(CONFIG_M68K)
     initr_trap,
 #endif
 #ifdef CONFIG_ADDR_MAP
     initr_addr_map,
 #endif
 #if defined(CONFIG_BOARD_EARLY_INIT_R)
     board_early_init_r,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_LOGBUFFER
     initr_logbuffer,
 #endif
 #ifdef CONFIG_POST
     initr_post_backlog,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_SYS_DELAYED_ICACHE
     initr_icache_enable,
 #endif
 #if defined(CONFIG_PCI) &amp;&amp; defined(CONFIG_SYS_EARLY_PCI_INIT)
     /*
      * Do early PCI configuration _before_ the flash gets initialised,
      * because PCU ressources are crucial for flash access on some boards.
      */
     initr_pci,
 #endif
 #ifdef CONFIG_WINBOND_83C553
     initr_w83c553f,
 #endif
 #ifdef CONFIG_ARCH_EARLY_INIT_R
     arch_early_init_r,
 #endif
     power_init_board,
 #ifndef CONFIG_SYS_NO_FLASH
     initr_flash,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_X86) || \
     defined(CONFIG_SPARC)
     /* initialize higher level parts of CPU like time base and timers */
     cpu_init_r,
 #endif
 #ifdef CONFIG_PPC
     initr_spi,
 #endif
 #ifdef CONFIG_CMD_NAND
     initr_nand,
 #endif
 #ifdef CONFIG_CMD_ONENAND
     initr_onenand,
 #endif
 #ifdef CONFIG_GENERIC_MMC
     initr_mmc,
 #endif
 #ifdef CONFIG_HAS_DATAFLASH
     initr_dataflash,
 #endif
     initr_env,
 #ifdef CONFIG_SYS_BOOTPARAMS_LEN
     initr_malloc_bootparams,
 #endif
     INIT_FUNC_WATCHDOG_RESET
     initr_secondary_cpu,
 #if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)
     mac_read_from_eeprom,
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #if defined(CONFIG_PCI) &amp;&amp; !defined(CONFIG_SYS_EARLY_PCI_INIT)
     /*
      * Do pci configuration
      */
     initr_pci,
 #endif
     stdio_add_devices,
     initr_jumptable,
 #ifdef CONFIG_API
     initr_api,
 #endif
     console_init_r,     /* fully init console as a device */
 #ifdef CONFIG_DISPLAY_BOARDINFO_LATE
     show_board_info,
 #endif
 #ifdef CONFIG_ARCH_MISC_INIT
     arch_misc_init,     /* miscellaneous arch-dependent init */
 #endif
 #ifdef CONFIG_MISC_INIT_R
     misc_init_r,        /* miscellaneous platform-dependent init */
 #endif
     INIT_FUNC_WATCHDOG_RESET
 #ifdef CONFIG_CMD_KGDB
     initr_kgdb,
 #endif
     interrupt_init,
 #if defined(CONFIG_ARM) || defined(CONFIG_AVR32)
     initr_enable_interrupts,
 #endif
 #if defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) || defined(CONFIG_M68K)
     timer_init,     /* initialize timer */
 #endif
 #if defined(CONFIG_STATUS_LED)
     initr_status_led,
 #endif
     /* PPC has a udelay(20) here dating from 2002. Why? */
 #ifdef CONFIG_CMD_NET
     initr_ethaddr,
 #endif
 #ifdef CONFIG_BOARD_LATE_INIT
     board_late_init,
 #endif
 #if defined(CONFIG_CMD_AMBAPP)
     ambapp_init_reloc,
 #if defined(CONFIG_SYS_AMBAPP_PRINT_ON_STARTUP)
     initr_ambapp_print,
 #endif
 #endif
 #ifdef CONFIG_CMD_SCSI
     INIT_FUNC_WATCHDOG_RESET
     initr_scsi,
 #endif
 #ifdef CONFIG_CMD_DOC
     INIT_FUNC_WATCHDOG_RESET
     initr_doc,
 #endif
 #ifdef CONFIG_BITBANGMII
     initr_bbmii,
 #endif
 #ifdef CONFIG_CMD_NET
     INIT_FUNC_WATCHDOG_RESET
     initr_net,
 #endif
 #ifdef CONFIG_POST
     initr_post,
 #endif
 #if defined(CONFIG_CMD_PCMCIA) &amp;&amp; !defined(CONFIG_CMD_IDE)
     initr_pcmcia,
 #endif
 #if defined(CONFIG_CMD_IDE)
     initr_ide,
 #endif
 #ifdef CONFIG_LAST_STAGE_INIT
     INIT_FUNC_WATCHDOG_RESET
     /*
      * Some parts can be only initialized if all others (like
      * Interrupts) are up and running (i.e. the PC-style ISA
      * keyboard).
      */
     last_stage_init,
 #endif
 #ifdef CONFIG_CMD_BEDBUG
     INIT_FUNC_WATCHDOG_RESET
     initr_bedbug,
 #endif
 #if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
     initr_mem,
 #endif
 #ifdef CONFIG_PS2KBD
     initr_kbd,
 #endif
 #if defined(CONFIG_SPARC)
     prom_init,
 #endif
     run_main_loop,
 };
</code></pre>
</div>

<p><code class="highlighter-rouge">init_sequence_r</code> 也很长，道理同 <code class="highlighter-rouge">init_sequence_f</code>，这里需要关注的是 <code class="highlighter-rouge">run_main_loop</code>，进入该函数后，就一路向前进入 uboot 的 shell 和系统引导代码，不在返回汇编了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int run_main_loop(void)
{
...
    /* main_loop() can return to retry autoboot, if so just run it again */
    for (;;)
        main_loop();
    return 0;
}
</code></pre>
</div>

<p>进入 <code class="highlighter-rouge">main_loop()</code> 以后，uboot 要么进入 shell 要么直接引导 Linux。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/* We come here after U-Boot is initialised and ready to process commands */
void main_loop(void)
{
...
    s = bootdelay_process();
...
    autoboot_command(s);

    cli_loop();
    panic("No CLI available");
}
</code></pre>
</div>

<p><code class="highlighter-rouge">main_loop()</code> 首先会等待一段时间检查用户是否有输入（<code class="highlighter-rouge">bootdelay_process()</code>），要进入 shell ，如果用户没有输入则直接执行默认的启动命令(<code class="highlighter-rouge">autoboot_command</code>)，否则进入 shell (<code class="highlighter-rouge">cli_loop</code>)，而 shell 就是个死循环，一直在等待用户输入命令。</p>

<p>注：不同架构处理器的启动代码逻辑（flash-&gt;cache-&gt;ddr，这三部分）的处理上还是有一些细节差别的。</p>


                

              </div>
              
            </div>
            <!-- JiaThis Button BEGIN -->
            <div class="jiathis_style">
                    <span class="jiathis_txt">分享到：</span>
                        <a class="jiathis_button_qzone">QQ空间</a>
                            <a class="jiathis_button_tsina">新浪微博</a>
                                <a class="jiathis_button_tqq">腾讯微博</a>
                                    <a class="jiathis_button_pocket">Pocket</a>
                                        <a class="jiathis_button_evernote">EverNote</a>
                                            <a class="jiathis_button_linkedin">LinkedIn</a>
                                                <a class="jiathis_button_fb">Facebook</a>
                                                    <a class="jiathis_button_weixin">微信</a>
                                                        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
                                                            <a class="jiathis_counter_style"></a>
            </div>
            <script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js" charset="utf-8"></script>
            <!-- JiaThis Button END -->
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="/study-notes/2016/07/%E5%BC%80%E5%A7%8B%E8%AE%A4%E7%9C%9F%E5%86%99%E7%AC%94%E8%AE%B0">开始认真写笔记</a></li>
    
    <li><a href="/study-notes/2016/07/%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E7%9A%84initcall">内核启动的initcall</a></li>
    
    <li><a href="/study-notes/2016/07/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E6%9E%90">Linux网络协议栈分析</a></li>
    
    <li><a href="/study-notes/2016/07/kernel%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B">Kernel初始化流程</a></li>
    
    <li><a href="/study-notes/2016/07/linux%E4%B8%8B%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95">Linux下拦截系统调用的一种方法</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Tags</h2>
  <ul>
    
      <li><a href="/study-notes/tag/工具">工具</a></li>
    
      <li><a href="/study-notes/tag/git">git</a></li>
    
      <li><a href="/study-notes/tag/shell">shell</a></li>
    
      <li><a href="/study-notes/tag/vagrant">vagrant</a></li>
    
      <li><a href="/study-notes/tag/ARM">ARM</a></li>
    
      <li><a href="/study-notes/tag/开发板">开发板</a></li>
    
      <li><a href="/study-notes/tag/beaglebone">beaglebone</a></li>
    
      <li><a href="/study-notes/tag/PPC">PPC</a></li>
    
      <li><a href="/study-notes/tag/android">android</a></li>
    
      <li><a href="/study-notes/tag/Knowledge">Knowledge</a></li>
    
      <li><a href="/study-notes/tag/个人">个人</a></li>
    
      <li><a href="/study-notes/tag/C/C++">C/C++</a></li>
    
      <li><a href="/study-notes/tag/Linux">Linux</a></li>
    
      <li><a href="/study-notes/tag/net">net</a></li>
    
      <li><a href="/study-notes/tag/RaspberryPi">RaspberryPi</a></li>
    
      <li><a href="/study-notes/tag/RTOS">RTOS</a></li>
    
      <li><a href="/study-notes/tag/u-boot">u-boot</a></li>
    
      <li><a href="/study-notes/tag/文件系统">文件系统</a></li>
    
      <li><a href="/study-notes/tag/协议栈">协议栈</a></li>
    
      <li><a href="/study-notes/tag/驱动">驱动</a></li>
    
      <li><a href="/study-notes/tag/Kernel">Kernel</a></li>
    
  </ul>
</div>

        </div>
      </div>
    </div>
    

  </div>

      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Ezio &copy; 2016</p>
          <h6>Follow me</h6>

<ul class="social-media">

  
    <li>
      <a title="oska874 on Github" href="https://github.com/oska874" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="1294322 on StackOverflow" href="http://stackoverflow.com/users/1294322" target="_blank"><i class="fa fa-stack-overflow fa-2x"></i></a>
    </li>
  

  
    <li>
      <a title="oska874 on LinkedIn" href="https://www.linkedin.com/in/zhang-lei-1b41b669" target="_blank"><i class="fa fa-linkedin fa-2x"></i></a>
    </li>
  

  

  

  
    <li>
      <a title="feed.xml RSS" href="/study-notes/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>

        </div>
      </div>
    </footer>
  </body>
</html>

</div>

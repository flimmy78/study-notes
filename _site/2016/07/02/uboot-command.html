
<h1 id="uboot-shell-">uboot shell 命令</h1>

<h2 id="uboot-shell--1">4. uboot shell 命令的实现</h2>

<h3 id="section">4.1. 添加命令</h3>

<p>以命令 <code>boot</code> 为例（<code>cmd/bootm.c</code>），添加该命令使用了下面的语句：</p>

<pre><code>U_BOOT_CMD(
    boot,   1,  1,  do_bootd,
    "boot default, i.e., run 'bootcmd'",
    ""
);
</code></pre>

<p>这段语句可以这么理解：给 uboot 添加了一条 shell 命令 <code>boot</code>，它的作用是引导、启动操作系统(<code>boot default, i.e., run 'bootcmd'</code>)，实现命令的函数是 <code>do_bootd</code>。</p>

<p>之所以这么一条语句就可以完成添加 shell 命令，可以参考 U_BOOT_CMD 的实现：</p>

<pre><code>#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)      \
    U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)
</code></pre>

<pre><code>#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \
    ll_entry_declare(cmd_tbl_t, _name, cmd) =           \
        U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,  \
                        _usage, _help, _comp);
</code></pre>

<pre><code>#define ll_entry_declare(_type, _name, _list)               \
    _type _u_boot_list_2_##_list##_2_##_name __aligned(4)       \
            __attribute__((unused,              \
            section(".u_boot_list_2_"#_list"_2_"#_name)))
</code></pre>

<pre><code>#define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,      \
                _usage, _help, _comp)           \
        { #_name, _maxargs, _rep, _cmd, _usage,         \
            _CMD_HELP(_help) _CMD_COMPLETE(_comp) }
</code></pre>

<pre><code># define _CMD_HELP(x) x,
# define _CMD_COMPLETE(x) x,
</code></pre>

<p>通过逐层解析宏 <code>U_BOOT_CMD</code>，最终会得到：</p>

<pre><code>cmd_tbl_t _u_boot_list_2_cmd_2_boot __aligned(4) __attribute__((unused, section(".u_boot_list_2_cmd_2_boot"))) = {
        `boot`,
        1,
        1,
        do_bootd,
        "boot default, i.e., run 'bootcmd'",
        "",
        };


</code></pre>

<p>在 u-boot.lds 中会链接 .u_boot_list_2_cmd_2_boot ：</p>

<pre><code>. = ALIGN(4);
.u_boot_list : {
 KEEP(*(SORT(.u_boot_list*)));
}
</code></pre>

<p>注：其中 SORT 会按照名称的的顺序进行链接。</p>

<p>cmd_tbl_t 定义如下(成员变量 complete 暂不讨论)：</p>

<pre><code>typedef struct cmd_tbl_s    cmd_tbl_t;
struct cmd_tbl_s {
    char        *name;      /* Command Name         */
    int         maxargs;    /* maximum number of arguments  */
    int         repeatable; /* autorepeat allowed?      */
                    /* Implementation function  */
    int         (*cmd)(struct cmd_tbl_s *, int, int, char * const []);
    char        *usage;     /* Usage message    (short) */
#ifdef  CONFIG_SYS_LONGHELP
    char        *help;      /* Help  message    (long)  */
#endif
#ifdef CONFIG_AUTO_COMPLETE
    /* do auto completion on the arguments */
    int     (*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);
#endif
};
</code></pre>

<p>综上，  <code>U_BOOT_CMD(...)</code> 实际上是定义了一个结构体变量，这个结构体定义了 uboot 的 shell 命令要用到的信息，并且这个结构体变量是保存在指定的位置（<code>section(".u_boot_list_2_cmd_2_boot")</code>)。 uboot 运行时会主动在该 section 寻找命令并执行。</p>

<h3 id="section-1">4.2. 执行命令</h3>

<p>uboot 的 shell 入口是 <code>common/board_r.c</code> 的 run_main_loop() :</p>

<pre><code>static int run_main_loop(void)
{
#ifdef CONFIG_SANDBOX
    sandbox_main_loop_init();
#endif
    /* main_loop() can return to retry autoboot, if so just run it again */
    for (;;)
        main_loop();
    return 0;
}
</code></pre>

<p><code>main_loop()</code> 会重复执行，处理输入的命令</p>

<p><code>common/main.c</code> 的 main_loop ：
```
/* We come here after U-Boot is initialised and ready to process commands */
void main_loop(void)
{
    const char *s;</p>

<p>…
    cli_init();
…
    s = bootdelay_process();
    if (cli_process_fdt(&amp;s))
        cli_secure_boot_cmd(s);</p>

<pre><code>autoboot_command(s);

cli_loop(); ... } ```
</code></pre>

<p>其中 <code>cli_loop()</code> 是执行命令的具体函数 ：</p>

<pre><code>void cli_loop(void)
{
...
    parse_file_outer();
    /* This point is never reached */
    for (;;);
...
}
</code></pre>

<p><code>parse_file_outer()</code> 会调用 <code>parse_stream_outer()</code> 解析输入的命令并调用 run_list() 执行命令 :</p>

<pre><code>static int parse_stream_outer(struct in_str *inp, int flag)
{
...
    do {
        ...
            run_list(ctx.list_head);
...
    /* loop on syntax errors, return on EOF */
    } while (rcode != -1 &amp;&amp; !(flag &amp; FLAG_EXIT_FROM_LOOP) &amp;&amp;
        (inp-&gt;peek != static_peek || b_peek(inp)));
...
}
</code></pre>

<p>接着顺着函数调用链 <code>run_list() -&gt; run_list_real() -&gt; run_pipe_real() -&gt; cmd_process()</code> uboot 进入到 cmd_process() 开始准备执行命令。</p>

<pre><code>enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
                   int *repeatable, ulong *ticks)
{
    enum command_ret_t rc = CMD_RET_SUCCESS;
    cmd_tbl_t *cmdtp;

    /* Look up command in command table */
    cmdtp = find_cmd(argv[0]);
    if (cmdtp == NULL) {
        printf("Unknown command '%s' - try 'help'\n", argv[0]);
        return 1;
    }

    /* found - check max args */
    if (argc &gt; cmdtp-&gt;maxargs)
        rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
    /* avoid "bootd" recursion */
    else if (cmdtp-&gt;cmd == do_bootd) {
        if (flag &amp; CMD_FLAG_BOOTD) {
            puts("'bootd' recursion detected\n");
            rc = CMD_RET_FAILURE;
        } else {
            flag |= CMD_FLAG_BOOTD;
        }
    }
#endif

    /* If OK so far, then do the command */
    if (!rc) {
        if (ticks)
            *ticks = get_timer(0);
        rc = cmd_call(cmdtp, flag, argc, argv);
        if (ticks)
            *ticks = get_timer(*ticks);
        *repeatable &amp;= cmdtp-&gt;repeatable;
    }
    if (rc == CMD_RET_USAGE)
        rc = cmd_usage(cmdtp);
    return rc;
}
</code></pre>

<p>其中 <code>find_cmd()</code> 用来在保存命令的 <code>u_boot_list*</code> 段内寻找命令对应的结构体变量，然后 <code>cmd_call()</code> 调用结构体变量对应的函数，到此命令执行完成。</p>

<h3 id="section-2">4.3. 命令解析</h3>

<p>命令解析有三部分：输入命令、找到命令、执行命令。</p>

<h4 id="section-3">4.3.1. 输入命令</h4>

<p>uboot shell 的命令都是通过串口输入的，s用户输入字符串后会由 uboot 对字符串进行解析，最终获得命令、命令参数。</p>

<h4 id="section-4">4.3.2. 找到命令</h4>

<p>通过串口输入获取到命令名称和命令参数后，要在 section .u_boot_list_2_cmd_2* 找到命令的结构体变量，根据结构体变量调用命令背后的函数。</p>

<p>寻找命令的函数是 <code>cmd_tbl_t *find_cmd()</code> ，函数返回了对应的命令结构体变量 ：</p>

<pre><code>cmd_tbl_t *find_cmd(const char *cmd)
{
    cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
    const int len = ll_entry_count(cmd_tbl_t, cmd);
    return find_cmd_tbl(cmd, start, len);
}
</code></pre>

<pre><code>#define ll_entry_start(_type, _list)                    \
({                                  \
    static char start[0] __aligned(4) __attribute__((unused,    \
        section(".u_boot_list_2_"#_list"_1")));         \
    (_type *)&amp;start;                        \
})
</code></pre>

<pre><code>#define ll_entry_count(_type, _list)                    \
    ({                              \
        _type *start = ll_entry_start(_type, _list);        \
        _type *end = ll_entry_end(_type, _list);        \
        unsigned int _ll_result = end - start;          \
        _ll_result;                     \
    })
</code></pre>

<pre><code>#define ll_entry_end(_type, _list)                  \
({                                  \
    static char end[0] __aligned(4) __attribute__((unused,      \
        section(".u_boot_list_2_"#_list"_3")));         \
    (_type *)&amp;end;                          \
})
</code></pre>

<p>而命令的结构体变量 <code>.u_boot_list_2_*_2*</code> 正好位于 <code>.u_boot_list_2_"#_list"_1"</code> 和 <code>.u_boot_list_2_"#_list"_3"</code> 之间，这样就获取到了 <code>.u_boot_list_2_*_2*</code> 的长度，然后调用函数 <code>find_cmd_tbl()</code> 遍历该 section 、寻找命令对应的结构体变量并返回给 shell。</p>

<pre><code>cmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)
{
...
    for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
        if (strncmp(cmd, cmdtp-&gt;name, len) == 0) {
            if (len == strlen(cmdtp-&gt;name))
                return cmdtp;   /* full match */

            cmdtp_temp = cmdtp; /* abbreviated command ? */
            n_found++;
        }
    }
...
}
</code></pre>

<h4 id="section-5">4.3.3. 执行命令</h4>

<p>cmd_process() 调用 cmd_call() 执行命令，很简单就是直接调用命令结构体变量的成员函数 ：</p>

<pre><code>static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
   ...
    result = (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);
   ....
}
</code></pre>


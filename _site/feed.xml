<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Ezio's Notes</title>
		<description>Embedded Software Developer , BSP and OS develop .</description>
		<link>/study-notes</link>
		<atom:link href="/study-notes/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>开始认真写笔记</title>
				<description>&lt;p&gt;今天是个好日子，经过两天的折腾，总算在 github 上把自己的笔记集搭起来了，不得不说现在 web 技术发展的很棒，写几个 markdown 文件，在托管平台上申请个账户就可以制作一个效果很棒的个人静态网站了。&lt;/p&gt;

&lt;p&gt;之前我也私下做一些笔记，记录下自己工作中遇到的问题，以及自己业余时间学习的一些技术、工具，虽然时间很久，几乎是自工作起就开始做笔记了，但是因为受众只有我一个，所以记录的比较天马行空、不拘一格，对其他人来说近乎天书。不过最近开始想好好提高自己的写作表达能力 —— 其实是最近工作写了太多文档、手册，有些上瘾了，所以从现在开始我也来做一个自己的技术笔记集。&lt;/p&gt;

&lt;p&gt;大家可以看到这里已经有了好几篇文章，大部分都是最近做的笔记，挑了几篇自我感觉良好的，没有做太大的改动就放上来了，先充充门面，以后写的一定会比这些更好的。拭目以待。&lt;/p&gt;

</description>
				<pubDate>Fri, 08 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/%E5%BC%80%E5%A7%8B%E8%AE%A4%E7%9C%9F%E5%86%99%E7%AC%94%E8%AE%B0</link>
				<guid isPermaLink="true">/study-notes/2016/07/%E5%BC%80%E5%A7%8B%E8%AE%A4%E7%9C%9F%E5%86%99%E7%AC%94%E8%AE%B0</guid>
			</item>
		
			<item>
				<title>内核启动的initcall</title>
				<description>&lt;h1 id=&quot;initcall&quot;&gt;initcall&lt;/h1&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;initcall 定义&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;initcall 的执行&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&quot;initcall-&quot;&gt;1. initcall 定义&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define early_initcall(fn)      __define_initcall(fn, early)
#define pure_initcall(fn)       __define_initcall(fn, 0)

#define core_initcall(fn)       __define_initcall(fn, 1)
#define core_initcall_sync(fn)      __define_initcall(fn, 1s)
#define postcore_initcall(fn)       __define_initcall(fn, 2)
#define postcore_initcall_sync(fn)  __define_initcall(fn, 2s)
#define arch_initcall(fn)       __define_initcall(fn, 3)
#define arch_initcall_sync(fn)      __define_initcall(fn, 3s)
#define subsys_initcall(fn)     __define_initcall(fn, 4)
#define subsys_initcall_sync(fn)    __define_initcall(fn, 4s)
#define fs_initcall(fn)         __define_initcall(fn, 5)
#define fs_initcall_sync(fn)        __define_initcall(fn, 5s)
#define rootfs_initcall(fn)     __define_initcall(fn, rootfs)
#define device_initcall(fn)     __define_initcall(fn, 6)
#define device_initcall_sync(fn)    __define_initcall(fn, 6s)
#define late_initcall(fn)       __define_initcall(fn, 7)
#define late_initcall_sync(fn)      __define_initcall(fn, 7s)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终都是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;__define_initcall&lt;/code&gt; 实现的 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define __define_initcall(fn, id) \
    static initcall_t __initcall_##fn##id __used \
    __attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) = fn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是说经过 &lt;code class=&quot;highlighter-rouge&quot;&gt;*_initcall&lt;/code&gt; 修饰的函数最终都会按照顺序放到 section &lt;code class=&quot;highlighter-rouge&quot;&gt;.initcall#id#.init&lt;/code&gt; 中，然后kernel 会按照顺序执行这些函数。&lt;/p&gt;

&lt;p&gt;而在 &lt;code class=&quot;highlighter-rouge&quot;&gt;include/asm-generic/vmlinux.lds.h&lt;/code&gt; 里面已经定义好了对应的 section ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define INIT_DATA_SECTION(initsetup_align)              \
    .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) {       \
        INIT_DATA                       \
        INIT_SETUP(initsetup_align)             \
        INIT_CALLS                      \
        CON_INITCALL                        \
        SECURITY_INITCALL                   \
        INIT_RAM_FS                     \
    }
#define VMLINUX_SYMBOL(x) __VMLINUX_SYMBOL(x)

#define INIT_CALLS_LEVEL(level)                     \
        VMLINUX_SYMBOL(__initcall##level##_start) = .;      \
        *(.initcall##level##.init)              \
        *(.initcall##level##s.init)             \

#define INIT_CALLS                          \
        VMLINUX_SYMBOL(__initcall_start) = .;           \
        *(.initcallearly.init)                  \
        INIT_CALLS_LEVEL(0)                 \
        INIT_CALLS_LEVEL(1)                 \
        INIT_CALLS_LEVEL(2)                 \
        INIT_CALLS_LEVEL(3)                 \
        INIT_CALLS_LEVEL(4)                 \
        INIT_CALLS_LEVEL(5)                 \
        INIT_CALLS_LEVEL(rootfs)                \
        INIT_CALLS_LEVEL(6)                 \
        INIT_CALLS_LEVEL(7)                 \
        VMLINUX_SYMBOL(__initcall_end) = .;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终编译内核使用 lds 链接脚本 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(arch)/kernel/vmlinux.lds&lt;/code&gt; 中就有：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INIT_DATA_SECTION(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;initcall--1&quot;&gt;2. initcall 的执行&lt;/h2&gt;

&lt;p&gt;kernel 启动过程中会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;init/main.c&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;start_kernel()&lt;/code&gt;，然后按照下面的调用链最终会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;do_initcalls()&lt;/code&gt; 执行这些初始化函数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start_kernel()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rest_init()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel_thread(kernel_init)&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel_init_freeable()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;do_basic_setup()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;do_initcalls()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;do_initcall_level()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而执行的顺序就跟各个宏的定义有关，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;pure_initcall&lt;/code&gt; 实际上是 &lt;code class=&quot;highlighter-rouge&quot;&gt;__define_initcall(fn, 0)&lt;/code&gt; 所以它会被首先执行，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;late_initcall&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;__define_initcall(fn, 7)&lt;/code&gt; 所以会最后执行。具体的执行如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void __init do_initcalls(void)
{
    int level;

    for (level = 0; level &amp;lt; ARRAY_SIZE(initcall_levels) - 1; level++)
        do_initcall_level(level);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;do_initcall_level()&lt;/code&gt; 会执行每个 section 内部的所有初始化函数 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void __init do_initcall_level(int level)
{
...
    for (fn = initcall_levels[level]; fn &amp;lt; initcall_levels[level+1]; fn++)
        do_one_initcall(*fn);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;do_initcall_level()&lt;/code&gt; 按顺序遍历每个 section 执行所有函数。&lt;/p&gt;

&lt;p&gt;两个相关的数组，&lt;code class=&quot;highlighter-rouge&quot;&gt;initcall_levels&lt;/code&gt; 指向了每个 section 的起始地址，也就是第一个函数地址，&lt;code class=&quot;highlighter-rouge&quot;&gt;initcall_level_names&lt;/code&gt; 则将 section 的顺序号（就是 0,1,2,3 这些）和初始化函数的含义关联起来（比如 0 对应 early ，1 对应 core）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static initcall_t *initcall_levels[] __initdata = {
    __initcall0_start,
    __initcall1_start,
    __initcall2_start,
    __initcall3_start,
    __initcall4_start,
    __initcall5_start,
    __initcall6_start,
    __initcall7_start,
    __initcall_end,
};

/* Keep these in sync with initcalls in include/linux/init.h */
static char *initcall_level_names[] __initdata = {
    &quot;early&quot;,
    &quot;core&quot;,
    &quot;postcore&quot;,
    &quot;arch&quot;,
    &quot;subsys&quot;,
    &quot;fs&quot;,
    &quot;device&quot;,
    &quot;late&quot;,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
				<pubDate>Wed, 06 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E7%9A%84initcall</link>
				<guid isPermaLink="true">/study-notes/2016/07/%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E7%9A%84initcall</guid>
			</item>
		
			<item>
				<title>Linux网络协议栈分析</title>
				<description>&lt;h1 id=&quot;linux-&quot;&gt;Linux 网络协议栈&lt;/h1&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;socket 和文件系统都位于 VFS 下一层，对 socket 的操作都要经过 VFS&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;netstack 初始化
        &lt;ul&gt;
          &lt;li&gt;2.1. &lt;code class=&quot;highlighter-rouge&quot;&gt;sock_init\(\)&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;2.1. skb&lt;/li&gt;
          &lt;li&gt;(skb 待补充)&lt;/li&gt;
          &lt;li&gt;2.2. sockfs 初始化&lt;/li&gt;
          &lt;li&gt;2.3. 网络协议初始化&lt;/li&gt;
          &lt;li&gt;2.4. network namespace subsystem&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&quot;socket--vfs--socket--vfs&quot;&gt;1. socket 和文件系统都位于 VFS 下一层，对 socket 的操作都要经过 VFS&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/study-notes/download/sockfs-vfs.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;linux 里面每个文件都有唯一的 inode ，inode 会大量使用，为了提高效率会对 inode 进行缓存；&lt;/li&gt;
  &lt;li&gt;vfs 要调用具体的文件系统就需要知道每个文件系统的信息，这些信息都放在各自的超级块（super_block) 里，需要文件系统注册（&lt;code class=&quot;highlighter-rouge&quot;&gt;register_filesystem&lt;/code&gt;）把自己挂到 VFS 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;file_systems&lt;/code&gt; 全局链表上，然后通过挂载（&lt;code class=&quot;highlighter-rouge&quot;&gt;kern_mount&lt;/code&gt;）自己、将超级块告知 VFS 。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;netstack-&quot;&gt;2. netstack 初始化&lt;/h2&gt;

&lt;p&gt;内核使用 init.h 中定义的初始化宏来进行，即将初始化函数放入特定的代码段去执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;core_initcall(sock_init);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相关的宏和初始化函数还包括&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;core_initcall：      sock_init 
fs_initcall：        inet_init 
subsys_initcall：    net_dev_init 
device_initcall:     设备驱动初始化 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面四种宏声明的函数是按顺序执行的。&lt;/p&gt;

&lt;h3 id=&quot;sockinit&quot;&gt;2.1. &lt;code class=&quot;highlighter-rouge&quot;&gt;sock_init()&lt;/code&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int __init sock_init(void)
{
    int err;
    /*
     *      Initialize the network sysctl infrastructure.
     */
    err = net_sysctl_init();
    if (err)
        goto out;

    /*
     *      Initialize skbuff SLAB cache
     */
    skb_init();

    /*
     *      Initialize the protocols module.
     */

    init_inodecache();

    err = register_filesystem(&amp;amp;sock_fs_type);
    if (err)
        goto out_fs;
    sock_mnt = kern_mount(&amp;amp;sock_fs_type);
    if (IS_ERR(sock_mnt)) {
        err = PTR_ERR(sock_mnt);
        goto out_mount;
    }

    /* The real protocol initialization is performed in later initcalls.
     */

#ifdef CONFIG_NETFILTER
    err = netfilter_init();
    if (err)
        goto out;
#endif

#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING
    skb_timestamping_init();
#endif

out:
    return err;

out_mount:
    unregister_filesystem(&amp;amp;sock_fs_type);
out_fs:
    goto out;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sock_init()&lt;/code&gt; 可以分为 4 部分 ： 初始化网络的系统调用（&lt;code class=&quot;highlighter-rouge&quot;&gt;net_sysctl_init&lt;/code&gt;）、初始化 skb 缓存(&lt;code class=&quot;highlighter-rouge&quot;&gt;skb_init&lt;/code&gt;)、初始化 VFS 相关(&lt;code class=&quot;highlighter-rouge&quot;&gt;init_inodecache&lt;/code&gt;、  &lt;code class=&quot;highlighter-rouge&quot;&gt;register_filesystem&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;kern_mount&lt;/code&gt;)、初始化网络过滤模块（&lt;code class=&quot;highlighter-rouge&quot;&gt;netfilter_init&lt;/code&gt;）。&lt;/p&gt;

&lt;h3 id=&quot;skb&quot;&gt;2.1. skb&lt;/h3&gt;
&lt;p&gt;数据包在应用层称为 data，在 TCP 层称为 segment，在 IP 层称为 packet，在数据链路层称为 frame。 Linux 内核中 &lt;code class=&quot;highlighter-rouge&quot;&gt;sk_buff&lt;/code&gt; 结构来存放数据。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;sk_buff 结构体&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sk_buff {
    /* These two members must be first. */
    struct sk_buff      *next;
    struct sk_buff      *prev;

    ktime_t         tstamp;

    struct sock     *sk;
    struct net_device   *dev;

    /*
     * This is the control buffer. It is free to use for every
     * layer. Please put your private variables there. If you
     * want to keep them across layers you have to do a skb_clone()
     * first. This is owned by whoever has the skb queued ATM.
     */
#ifdef CONFIG_AS_FASTPATH
    char            cb[96] __aligned(8);
#else
    char            cb[48] __aligned(8);
#endif
    unsigned long       _skb_refdst;
#ifdef CONFIG_XFRM
    struct  sec_path    *sp;
#endif
    unsigned int        len,
                data_len;
    __u16           mac_len,
                hdr_len;
    union {
        __wsum      csum;
        struct {
            __u16   csum_start;
            __u16   csum_offset;
        };
    };
    __u32           priority;
    kmemcheck_bitfield_begin(flags1);
    __u8            local_df:1,
                cloned:1,
                ip_summed:2,
                nohdr:1,
                nfctinfo:3;
    __u8            pkt_type:3,
                fclone:2,
                ipvs_property:1,
                peeked:1,
                nf_trace:1;
    kmemcheck_bitfield_end(flags1);
    __be16          protocol;

    void            (*destructor)(struct sk_buff *skb);
#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
    struct nf_conntrack *nfct;
#endif
#ifdef CONFIG_BRIDGE_NETFILTER
    struct nf_bridge_info   *nf_bridge;
#endif

    int         skb_iif;

    __u32           rxhash;

    __be16          vlan_proto;
    __u16           vlan_tci;

#ifdef CONFIG_NET_SCHED
    __u16           tc_index;   /* traffic control index */
#ifdef CONFIG_NET_CLS_ACT
    __u16           tc_verd;    /* traffic control verdict */
#endif
#endif

    __u16           queue_mapping;
    kmemcheck_bitfield_begin(flags2);
#ifdef CONFIG_IPV6_NDISC_NODETYPE
    __u8            ndisc_nodetype:2;
#endif
    __u8            pfmemalloc:1;
    __u8            ooo_okay:1;
    __u8            l4_rxhash:1;
    __u8            wifi_acked_valid:1;
    __u8            wifi_acked:1;
    __u8            no_fcs:1;
    __u8            head_frag:1;
    /* Encapsulation protocol and NIC drivers should use
     * this flag to indicate to each other if the skb contains
     * encapsulated packet or not and maybe use the inner packet
     * headers if needed
     */
    __u8            encapsulation:1;
    /* 6/8 bit hole (depending on ndisc_nodetype presence) */
    kmemcheck_bitfield_end(flags2);

#if defined CONFIG_NET_DMA || defined CONFIG_NET_RX_BUSY_POLL
    union {
        unsigned int    napi_id;
        dma_cookie_t    dma_cookie;
    };
#endif
#ifdef CONFIG_NETWORK_SECMARK
    __u32           secmark;
#endif
    union {
        __u32       mark;
        __u32       dropcount;
        __u32       reserved_tailroom;
    };

    __be16          inner_protocol;
    __u16           inner_transport_header;
    __u16           inner_network_header;
#if defined(CONFIG_GIANFAR) &amp;amp;&amp;amp; defined(CONFIG_AS_FASTPATH)
    __u8            owner;
    struct sk_buff      *new_skb;
#endif
    __u16           inner_mac_header;
    __u16           transport_header;
    __u16           network_header;
    __u16           mac_header;
    /* These elements must be at the end, see alloc_skb() for details.  */
    sk_buff_data_t      tail;
    sk_buff_data_t      end;
    unsigned char       *head,
                *data;
    unsigned int        truesize;
    atomic_t        users;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中几个主要的成员是 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sk_buff      *next;      //sk_buff 是以链表组织起来的，需要知道前后两个 sk_buff 的位置
struct sk_buff      *prev;
struct net_device   *dev;       //数据报所属的网络设备
unsigned int        len,        //全部数据的长度
                data_len;       //当前 sk_buff 的分片数据长度
__be16          protocol;       //所属报文的协议类型
__u8            pkt_type:3;     //该数据包的类型
unsigned char   *data;          //保存的数据 
atomic_t        users;          //每引用或“克隆”一次 sk_buff 的时候，都自加 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;协议类型&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;宏&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;值&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ETH_P_802_2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;真正的 802.2 LLC，当报文长度小于 1536 时&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ETH_P_LOOP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0x0060&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;以太网环回报文&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ETH_P_IP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0x0800&lt;/td&gt;
      &lt;td&gt;IP 报文&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ETH_P_ARP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0x0806&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ARP 报文&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BOND_ETH_P_LACPDU&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0x8809&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LACP 协议报文&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ETH_P_8021Q&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0x8100&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VLAN 报文&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ETH_P_MPLS_UC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0x8847&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MPLS 单播报文&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;数据包类型&lt;/p&gt;

&lt;p&gt;宏                      |值      |说明 &lt;br /&gt;
:–                     |:–     |:–&lt;br /&gt;
PACKET_HOST             |0       |该报文的目的地是本机 &lt;br /&gt;
PACKET_BROADCAST        |1       |广播数据包，该 报文的目的地是所有主机&lt;br /&gt;
PACKET_MULTICAST        |2       |组播数据包 &lt;br /&gt;
PACKET_OTHERHOST        |3       |到其他主机的数据包，在 VLAN 接口接收数据时有用 &lt;br /&gt;
PACKET_OUTGOING         |4       |它不是“发送到外部主机的报文”，而是指接收的类型，这&lt;br /&gt;
种类型用在 AF_PACKET 的套接字上，这是 Linux 的扩展&lt;br /&gt;
PACKET_LOOPBACK         |5       |MC/BRD 的 loopback 帧（用户层不可见）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;skb_init()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;skb_init()&lt;/code&gt; 创建了两个缓存 &lt;code class=&quot;highlighter-rouge&quot;&gt;skbuff_head_cache&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;skbuff_fclone_cache&lt;/code&gt; ，协议栈中所使用到的所有的 sk_buff 结构都是从这两个后备高速缓存中分配出来的，两者的区别在于前者是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(struct sk_buff)&lt;/code&gt; 为单位创建的，是用来存放单纯的 sk_buff ，后者是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;2*sizeof(struct sk_buff)+sizeof(atomic_t)&lt;/code&gt; 为单位创建的，这一对 sk_buff 是克隆的，即它们指向同一个数据缓冲区，引用计数值是 0，1 或 2， 表示这一对&lt;br /&gt;
中有几个 sk_buff 已被使用。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;sk_buff 的使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分配 &lt;code class=&quot;highlighter-rouge&quot;&gt;alloc_skb()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;销毁 &lt;code class=&quot;highlighter-rouge&quot;&gt;kfree_skb()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分包/组包&lt;/strong&gt; ：&lt;/p&gt;

&lt;h5 id=&quot;skb-&quot;&gt;(skb 待补充)&lt;/h5&gt;

&lt;h3 id=&quot;sockfs-&quot;&gt;2.2. sockfs 初始化&lt;/h3&gt;

&lt;p&gt;网络通信可以被看作对文件的操作，socket 也是一种文件。网络初始化首先就要初始化 网络文件系统（sockfs）。&lt;/p&gt;

&lt;p&gt;第一步是初始化 inode 缓冲(&lt;code class=&quot;highlighter-rouge&quot;&gt;init_inodecache&lt;/code&gt;)，为 sockfs 的 inode 分配一片高速缓存 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int init_inodecache(void)
{
    sock_inode_cachep = kmem_cache_create(&quot;sock_inode_cache&quot;,
                          sizeof(struct socket_alloc),
                          0,
                          (SLAB_HWCACHE_ALIGN |
                           SLAB_RECLAIM_ACCOUNT |
                           SLAB_MEM_SPREAD),
                          init_once);
    if (sock_inode_cachep == NULL)
        return -ENOMEM;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着注册 sockfs 这种文件系统类型到 VFS 并将 sockfs 注册到 &lt;strong&gt;super_blocks&lt;/strong&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
init_inodecache();

err = register_filesystem(&amp;amp;sock_fs_type);

sock_mnt = kern_mount(&amp;amp;sock_fs_type);
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样以后创建 socket 就是在 sockfs 文件系统里创建一个特殊的文件，而文件系统的 &lt;code class=&quot;highlighter-rouge&quot;&gt;super_block&lt;/code&gt; 里面有一个成员变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct super_operations   *s_op;&lt;/code&gt; 记录了文件系统支持的操作函数，而这些操作函数都是让 VFS 来调用的，这样一来 socket 的表现就更像一个普通文件，支持大部分操作接口比如 write 、read 、close 等。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;2.3. 网络协议初始化&lt;/h3&gt;

&lt;p&gt;按照上文所述的协议栈初始化顺序， 网络文件系统初始化(&lt;code class=&quot;highlighter-rouge&quot;&gt;sock_init&lt;/code&gt;) 结束之后就开始进入 网络协议初始化(由宏 &lt;code class=&quot;highlighter-rouge&quot;&gt;fs_initcall&lt;/code&gt; 修饰的&lt;code class=&quot;highlighter-rouge&quot;&gt;inet_init&lt;/code&gt;)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int __init inet_init(void)
{
...
    sysctl_local_reserved_ports = kzalloc(65536 / 8, GFP_KERNEL);
    if (!sysctl_local_reserved_ports)
        goto out;

    rc = proto_register(&amp;amp;tcp_prot, 1);
    if (rc)
        goto out_free_reserved_ports;

    rc = proto_register(&amp;amp;udp_prot, 1);
    if (rc)
        goto out_unregister_tcp_proto;

    rc = proto_register(&amp;amp;raw_prot, 1);
    if (rc)
        goto out_unregister_udp_proto;

    rc = proto_register(&amp;amp;ping_prot, 1);
    if (rc)
        goto out_unregister_raw_proto;

...
    /*
     *  Add all the base protocols.
     */

    if (inet_add_protocol(&amp;amp;icmp_protocol, IPPROTO_ICMP) &amp;lt; 0)
        pr_crit(&quot;%s: Cannot add ICMP protocol\n&quot;, __func__);
    if (inet_add_protocol(&amp;amp;udp_protocol, IPPROTO_UDP) &amp;lt; 0)
        pr_crit(&quot;%s: Cannot add UDP protocol\n&quot;, __func__);
    if (inet_add_protocol(&amp;amp;tcp_protocol, IPPROTO_TCP) &amp;lt; 0)
        pr_crit(&quot;%s: Cannot add TCP protocol\n&quot;, __func__);
#ifdef CONFIG_IP_MULTICAST
    if (inet_add_protocol(&amp;amp;igmp_protocol, IPPROTO_IGMP) &amp;lt; 0)
        pr_crit(&quot;%s: Cannot add IGMP protocol\n&quot;, __func__);
#endif

    /* Register the socket-side information for inet_create. */
    for (r = &amp;amp;inetsw[0]; r &amp;lt; &amp;amp;inetsw[SOCK_MAX]; ++r)
        INIT_LIST_HEAD(r);

    for (q = inetsw_array; q &amp;lt; &amp;amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)
        inet_register_protosw(q);

    /*
     *  Set the ARP module up
     */

    arp_init();

    /*
     *  Set the IP module up
     */

    ip_init();

    tcp_v4_init();

    /* Setup TCP slab cache for open requests. */
    tcp_init();

    /* Setup UDP memory threshold */
    udp_init();

    /* Add UDP-Lite (RFC 3828) */
    udplite4_register();

    ping_init();

    /*
     *  Set the ICMP layer up
     */

    if (icmp_init() &amp;lt; 0)
        panic(&quot;Failed to create the ICMP control socket.\n&quot;);

    /*
     *  Initialise the multicast router
     */
#if defined(CONFIG_IP_MROUTE)
    if (ip_mr_init())
        pr_crit(&quot;%s: Cannot init ipv4 mroute\n&quot;, __func__);
#endif
    /*
     *  Initialise per-cpu ipv4 mibs
     */

    if (init_ipv4_mibs())
        pr_crit(&quot;%s: Cannot init ipv4 mibs\n&quot;, __func__);

    ipv4_proc_init();

    ipfrag_init();

    dev_add_pack(&amp;amp;ip_packet_type);

    rc = 0;
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inet_init()&lt;/code&gt; 主要工作就是注册各种网络协议（如 icmp 、 tcp 、 udp 等）和初始化基础功能模块（如 arp 、 ip 等）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;协议初始化
    &lt;ul&gt;
      &lt;li&gt;ICMP&lt;/li&gt;
      &lt;li&gt;UDP&lt;/li&gt;
      &lt;li&gt;TCP&lt;/li&gt;
      &lt;li&gt;IGMP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;模块初始化
    &lt;ul&gt;
      &lt;li&gt;ARP&lt;/li&gt;
      &lt;li&gt;ipv4&lt;/li&gt;
      &lt;li&gt;tcp/udp/udplite ？&lt;/li&gt;
      &lt;li&gt;ping ？&lt;/li&gt;
      &lt;li&gt;icmp ？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;network-namespace-subsystem&quot;&gt;2.4. network namespace subsystem&lt;/h3&gt;

</description>
				<pubDate>Tue, 05 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E6%9E%90</link>
				<guid isPermaLink="true">/study-notes/2016/07/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E6%9E%90</guid>
			</item>
		
			<item>
				<title>Kernel初始化流程</title>
				<description>&lt;h1 id=&quot;kernel-&quot;&gt;kernel 初始化过程&lt;/h1&gt;

&lt;p&gt;内核启动后从汇编进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;start_kernel()&lt;/code&gt; ，然后会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rest_init()&lt;/code&gt; ，该函数会创建一个内核进程运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel_init()&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static noinline void __init_refok rest_init(void)
{
...
    /*
     * We need to spawn init first so that it obtains pid 1, however
     * the init task will end up wanting to create kthreads, which, if
     * we schedule it before we create kthreadd, will OOPS.
     */
    kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel_thread()&lt;/code&gt; 的原型是 ` pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);` ，创建一个内核线程。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel_init()&lt;/code&gt; 会创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 内核线程执行 init 任务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int __ref kernel_init(void *unused)
{
    ...
    if (ramdisk_execute_command) {
        if (!run_init_process(ramdisk_execute_command))
            return 0;
        pr_err(&quot;Failed to execute %s\n&quot;, ramdisk_execute_command);
    }
    if (execute_command) {
        if (!run_init_process(execute_command))
            return 0;
        pr_err(&quot;Failed to execute %s.  Attempting defaults...\n&quot;, execute_command);
    }
    if (!run_init_process(&quot;/sbin/init&quot;) ||
        !run_init_process(&quot;/etc/init&quot;) ||
        !run_init_process(&quot;/bin/init&quot;) ||
        !run_init_process(&quot;/bin/sh&quot;))
        return 0;

    panic(&quot;No init found.  Try passing init= option to kernel. &quot;
          &quot;See Linux Documentation/init.txt for guidance.&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;内核会根据实际情况、顺序选择执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ramdisk_execute_command&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;execute_command&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/init&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh&lt;/code&gt;，只要一个执行成功就会返回成功，否则进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;（未完待续）&lt;/p&gt;
</description>
				<pubDate>Tue, 05 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/kernel%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B</link>
				<guid isPermaLink="true">/study-notes/2016/07/kernel%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B</guid>
			</item>
		
			<item>
				<title>Linux下拦截系统调用的一种方法</title>
				<description>&lt;h1 id=&quot;linux-&quot;&gt;Linux 下拦截系统调用的一种方法&lt;/h1&gt;

&lt;p&gt;Linux允许让我们自己的动态链接库加载在其它动态链接库之前，甚至是系统库（如 libc.so.6），如此一来就可以写程序拦截替换系统的 &lt;code class=&quot;highlighter-rouge&quot;&gt;time()&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt; 这些函数。&lt;/p&gt;

&lt;p&gt;首先，我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt;函数会比较一下文件名是不是我们所想要打开的，如果是，则将文件描述符记录下来。然后， &lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt; 函数会判断如果我们调用的是不是我们所保存的文件描述符，如果是则代替它输出，否则调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt; 里面原来的函数。最后， &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt; 函数会关闭我们所保存的文件描述符。&lt;/p&gt;

&lt;p&gt;在这里我们借助了 &lt;code class=&quot;highlighter-rouge&quot;&gt;dlopen()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dlsym()&lt;/code&gt; 函数来确定原先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt; 的函数的地址，因为我们需要控制“真实”的函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;dlfcn.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
 
void *libc_handle = NULL;
int (*open_ptr)(const char *, int) = NULL;
int (*close_ptr)(int) = NULL;
ssize_t (*read_ptr)(int, void*, size_t) = NULL;
bool inited = false;
 
_Noreturn void die (const char * fmt, ...)
{
    va_list va;
    va_start (va, fmt);
    vprintf (fmt, va);
    exit(0);
};
 
static void find_original_functions ()
{
    if (inited)
        return;
    libc_handle = dlopen (&quot;libc.so.6&quot;, RTLD_LAZY);
    if (libc_handle==NULL)
        die (&quot;can&#39;t open libc.so.6\n&quot;);
    open_ptr = dlsym (libc_handle, &quot;open&quot;);
    if (open_ptr==NULL)
        die (&quot;can&#39;t find open()\n&quot;);
    close_ptr = dlsym (libc_handle, &quot;close&quot;);
    if (close_ptr==NULL)
        die (&quot;can&#39;t find close()\n&quot;);
    read_ptr = dlsym (libc_handle, &quot;read&quot;);
    if (read_ptr==NULL)
        die (&quot;can&#39;t find read()\n&quot;);
    inited = true;
}
 
static int opened_fd=0;
 
int open(const char *pathname, int flags)
{
    find_original_functions();
    int fd=(*open_ptr)(pathname, flags);
    if (strcmp(pathname, &quot;/proc/uptime&quot;)==0)
        opened_fd=fd; // that&#39;s our file! record its file descriptor
    else
        opened_fd=0;
    return fd;
};
 
int close(int fd)
{
    find_original_functions();
    if (fd==opened_fd)
        opened_fd=0; // the file is not opened anymore
    return (*close_ptr)(fd);
};
 
ssize_t read(int fd, void *buf, size_t count)
{
    find_original_functions();
    if (opened_fd!=0 &amp;amp;&amp;amp; fd==opened_fd)
    {
        // that&#39;s our file!
        return snprintf (buf, count, &quot;%d %d&quot;, 0x7fffffff, 0x7fffffff)+1;
    };
    // not our file, go to real read() function
    return (*read_ptr)(fd, buf, count);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把它编译成动态链接库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -fpic -shared -Wall -o fool_uptime.so fool_uptime.c -ldl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行uptime，并让它在加载其它库之前加载我们的库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LD_PRELOAD=`pwd`/fool_uptime.so uptime
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;01:23:02 up 24855 days, 3:14, 3 users, load average: 0.00, 0.01, 0.05
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;援引于 &lt;a href=&quot;http://drops.wooyun.org/binary/7452&quot;&gt;http://drops.wooyun.org/binary/7452&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 04 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/linux%E4%B8%8B%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95</link>
				<guid isPermaLink="true">/study-notes/2016/07/linux%E4%B8%8B%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95</guid>
			</item>
		
			<item>
				<title>Uboot驱动框架概述</title>
				<description>&lt;h1 id=&quot;section&quot;&gt;驱动框架&lt;/h1&gt;
&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;驱动框架
        &lt;ul&gt;
          &lt;li&gt;6.1. 声明&lt;/li&gt;
          &lt;li&gt;6.2. uclass&lt;/li&gt;
          &lt;li&gt;6.3. 调用&lt;/li&gt;
          &lt;li&gt;6.4. 设备的使用&lt;/li&gt;
          &lt;li&gt;6.5. 设备树&lt;/li&gt;
          &lt;li&gt;6.6. 小结&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&quot;section-1&quot;&gt;6. 驱动框架&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;6.1. 声明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方式 A&lt;/p&gt;

    &lt;p&gt;每个设备在 uboot 中都对应一个驱动结构体变量， uboot 操纵外设都是通过该结构体变量实现的。以 ti 的 cpsw 网卡为例，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;driver/net/cpsw.c&lt;/code&gt; 中定义了多个函数实现了网卡的收发、配置、中断处理等操作，然后通过结构体将这些操作集成到操作结构体 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct eth_ops&lt;/code&gt; 中：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static const struct eth_ops cpsw_eth_ops = { 
  .start      = cpsw_eth_start,
  .send       = cpsw_eth_send,
  .recv       = cpsw_eth_recv,
  .free_pkt   = cpsw_eth_free_pkt,
  .stop       = cpsw_eth_stop,
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这个结构体包含了网卡的主要操作：启停、收发等操作，但是这个结构体还是太底层了，不应该直接传给上层应用，也不能传给上层，uboot 的外设驱动架构是把全部的驱动放到一个 &lt;strong&gt;section 群&lt;/strong&gt;中，驱动结构体的成员是统一的，cpsw 驱动结构提其组成如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;U_BOOT_DRIVER(eth_cpsw) = {
  .name   = &quot;eth_cpsw&quot;,
  .id = UCLASS_ETH,
  .of_match = cpsw_eth_ids,
  .ofdata_to_platdata = cpsw_eth_ofdata_to_platdata,
  .probe  = cpsw_eth_probe,
  .ops    = &amp;amp;cpsw_eth_ops,
  .priv_auto_alloc_size = sizeof(struct cpsw_priv),
  .platdata_auto_alloc_size = sizeof(struct eth_pdata),
  .flags = DM_FLAG_ALLOC_PRIV_DMA, 
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;cpsw 驱动的成员包括了驱动名（name）、id、类型（of_match)、探针（probe）、操作（ops）等等。而这些驱动都是保存在同一个 &lt;strong&gt;section 群&lt;/strong&gt;中，这是通过宏 &lt;code class=&quot;highlighter-rouge&quot;&gt;U_BOOT_DRIVER&lt;/code&gt; 实现的：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Declare a new U-Boot driver */
#define U_BOOT_DRIVER(__name)                       \
  ll_entry_declare(struct driver, __name, driver)

#define ll_entry_declare(_type, _name, _list)               \
  _type _u_boot_list_2_##_list##_2_##_name __aligned(4)       \
          __attribute__((unused,              \
          section(&quot;.u_boot_list_2_&quot;#_list&quot;_2_&quot;#_name)))  
  
struct driver {
  char *name;
  enum uclass_id id;
  const struct udevice_id *of_match;
  int (*bind)(struct udevice *dev);
  int (*probe)(struct udevice *dev);
  int (*remove)(struct udevice *dev);
  int (*unbind)(struct udevice *dev);
  int (*ofdata_to_platdata)(struct udevice *dev);
  int (*child_post_bind)(struct udevice *dev);
  int (*child_pre_probe)(struct udevice *dev);
  int (*child_post_remove)(struct udevice *dev);
  int priv_auto_alloc_size;
  int platdata_auto_alloc_size;
  int per_child_auto_alloc_size;
  int per_child_platdata_auto_alloc_size;
  const void *ops;    /* driver-specific operations */
  uint32_t flags;
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这和之前 shell command 的实现类似。此处网卡驱动 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_cpsw&lt;/code&gt; 的结构体就是一个定义在段 &lt;code class=&quot;highlighter-rouge&quot;&gt;.u_boot_list_2_driver_2_eth_cpsw&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct driver&lt;/code&gt; 结构体（&lt;code class=&quot;highlighter-rouge&quot;&gt;_u_boot_list_2_driver_2_eth_cpsw&lt;/code&gt;)，定义好网卡驱动之后，其它应用就知道了结构体的名字和位置，从而可以使用该驱动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方式 B&lt;/p&gt;

    &lt;p&gt;方式 B 的驱动声明就相对简单多了 ， 实现网卡的各种操作接口还是必要的 ， 但是此时就不需要再声明定义额外的驱动结构体了，只需要定义一个网卡注册函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;cpsw_register()&lt;/code&gt; :&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int cpsw_register(struct cpsw_platform_data *data)
  {
    struct eth_device   *dev;
    ...
    priv-&amp;gt;dev = dev;           
    priv-&amp;gt;data = *data;        
                               
    strcpy(dev-&amp;gt;name, &quot;cpsw&quot;); 
    dev-&amp;gt;iobase = 0;           
    dev-&amp;gt;init   = cpsw_init;   
    dev-&amp;gt;halt   = cpsw_halt;   
    dev-&amp;gt;send   = cpsw_send;   
    dev-&amp;gt;recv   = cpsw_recv;   
    dev-&amp;gt;priv   = priv;        
                               
    eth_register(dev);         
                               
    ret = _cpsw_register(priv);
    if (ret &amp;lt; 0) {             
        eth_unregister(dev);   
        free(dev);             
        free(priv);            
        return ret;            
    }                          
                               
    return 1;                  
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cpsw_register()&lt;/code&gt; 中会网卡的操作函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;dev&lt;/code&gt; 关联，并且通过接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_register()&lt;/code&gt; (uboot 提供的网卡统一注册函数)与全局变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_register&lt;/code&gt; 关联起来，供上层应用使用。&lt;/p&gt;

&lt;h3 id=&quot;uclass&quot;&gt;6.2. uclass&lt;/h3&gt;

&lt;p&gt;uclass 是一组操作方式相似的设备。一个 uclass 提供了一种在一组设备中操作一个设备的方法，而且使用的是一组相同的接口。&lt;/p&gt;

&lt;p&gt;以 uboot 自带的 uclass demo 为例（&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/demo.c&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;uclass 的主要的数据结构是 &lt;code class=&quot;highlighter-rouge&quot;&gt;udevice&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct udevice {
    const struct driver *driver;
    const char *name;
    void *platdata;
    void *parent_platdata;
    void *uclass_platdata;
    int of_offset;
    ulong driver_data;
    struct udevice *parent;
    void *priv;
    struct uclass *uclass;
    void *uclass_priv;
    void *parent_priv;
    struct list_head uclass_node;
    struct list_head child_head;
    struct list_head sibling_node;
    uint32_t flags;
    int req_seq;
    int seq;
#ifdef CONFIG_DEVRES
    struct list_head devres_head;
#endif
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;uclass_driver&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct uclass_driver {                          
    const char *name;                           
    enum uclass_id id;                          
    int (*post_bind)(struct udevice *dev);      
    int (*pre_unbind)(struct udevice *dev);     
    int (*pre_probe)(struct udevice *dev);      
    int (*post_probe)(struct udevice *dev);     
    int (*pre_remove)(struct udevice *dev);     
    int (*child_post_bind)(struct udevice *dev);
    int (*child_pre_probe)(struct udevice *dev);
    int (*init)(struct uclass *class);          
    int (*destroy)(struct uclass *class);       
    int priv_auto_alloc_size;                   
    int per_device_auto_alloc_size;             
    int per_device_platdata_auto_alloc_size;    
    int per_child_auto_alloc_size;              
    int per_child_platdata_auto_alloc_size;     
    const void *ops;                            
    uint32_t flags;                             
};                                              
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而 &lt;code class=&quot;highlighter-rouge&quot;&gt;U_BOOT_DRIVER&lt;/code&gt; 定义的驱动也是属于 uclass 驱动。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;demo.c&lt;/code&gt; 中定义了一个结构体变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct udevice *demo_dev&lt;/code&gt; ， &lt;code class=&quot;highlighter-rouge&quot;&gt;do_demo()&lt;/code&gt; 实现了命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int do_demo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{                                                                            
    ...
        ret = uclass_get_device(UCLASS_DEMO, devnum, &amp;amp;demo_dev);             
    ...                    
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uclass_get_device()&lt;/code&gt; 完成两件事：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int uclass_get_device(enum uclass_id id, int index, struct udevice **devp)
{                                                                         
...                                                  
    ret = uclass_find_device(id, index, &amp;amp;dev);                            
    return uclass_get_device_tail(dev, ret, devp);                        
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;从 uclass 驱动所在的 section 找到找到 uclass driver&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;uboot 已经在 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo_uclass.c&lt;/code&gt; 定义了 demo 的 uclass 驱动结构体：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UCLASS_DRIVER(demo) = {   
    .name       = &quot;demo&quot;, 
    .id     = UCLASS_DEMO,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;do_demo() 要做的就是找到这个结构体变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int uclass_find_device(enum uclass_id id, int index, struct udevice **devp)
{                                                                          
 ...                                          
    ret = uclass_get(id, &amp;amp;uc);                                             
 ...
    list_for_each_entry(dev, &amp;amp;uc-&amp;gt;dev_head, uclass_node) {                 
        if (!index--) {                                                    
            *devp = dev;                                                   
            return 0;                                                      
        }                                                                  
    }                                                                      
 ...                                                      
}                                                                          
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先根据 uclass id 和设备 id 找到一组 uclass 设备驱动并且从中找到具体的某个设备。而 uclass id 就是上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;UCLASS_DEMO&lt;/code&gt; ，而设备 id 则是在具体设备定义的驱动中，比如 demo hello 驱动的定义 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static const struct udevice_id demo_shape_id[] = {
    { &quot;demo-simple&quot;, 0 },
    { },
};

U_BOOT_DRIVER(demo_simple_drv) = {
    .name   = &quot;demo_simple_drv&quot;,
    .of_match = demo_shape_id,
    .id = UCLASS_DEMO,
    .ofdata_to_platdata = demo_shape_ofdata_to_platdata,
    .ops    = &amp;amp;simple_ops,
    .platdata_auto_alloc_size = sizeof(struct dm_demo_pdata),
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设备 id 就是该设备在 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo_shape_id&lt;/code&gt; 的下标。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找到具体的设备之后就是初始化该设备。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int uclass_get_device_tail(struct udevice *dev, int ret,
                  struct udevice **devp)                
{                                                       
...                                       
    ret = device_probe(dev);                            
...                                          
}                                                       
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;找到找到设备驱动并进行初始化之后，就该执行设备提供的功能，比如 demo 提供的 hello 功能：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;=&amp;gt; demo hello 0
r@@@@@@@
e@@@@@@@
d@@@@@@@
r@@@@@@@
e@@@@@@@
d@@@@@@@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个功能的实现依赖于函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo_hello()&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int demo_hello(struct udevice *dev, int ch)
{
    const struct demo_ops *ops = device_get_ops(dev);

    if (!ops-&amp;gt;hello) 
        return -ENOSYS;
    
    return ops-&amp;gt;hello(dev, ch);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;dev&lt;/code&gt; 就是上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo_dev&lt;/code&gt;，以后的操作只需要调用结构体对应的操作函数即可。&lt;/p&gt;

&lt;h4 id=&quot;uclass-&quot;&gt;6.2.1. uclass 的内部结构&lt;/h4&gt;

&lt;p&gt;方式 B 驱动实现方式本质上就是 uclass 。简单来说， uclass 机制就是将外设分为多组，每组不同的设备都有一个相同的 ID （如上面的 UCLASS_DEMO），然后 uboot 在声明驱动时将所有的驱动按顺序连续保存在一起，运行时如果要使用某个设备就需要根据 ID 找到对应组的驱动，然后根据设备 ID 找到具体某个设备的驱动，后面使用设备就是执行这个驱动对应的操作函数。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;6.3. 调用&lt;/h3&gt;

&lt;p&gt;首先注册驱动，将具体设备的驱动和 uboot 的全局结构体（got？）关联起来。&lt;/p&gt;

&lt;p&gt;然后通过全局结构体调用具体的设备驱动。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
  int eth_send(void *packet, int length)
  {
    ...
    return eth_current-&amp;gt;send(eth_current, packet, length);
  } 
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uboot 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_current-&amp;gt;send&lt;/code&gt; 调用了实际网络设备的发送函数。现在要关注的是 eth_current 实际指向的驱动是哪个，以及该变量是何时、何处赋值的。 (详见 6.1 节)&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;6.4. 设备的使用&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;6.4.1. 网卡&lt;/h4&gt;

&lt;p&gt;如上所示 uboot 启动阶段会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;initr_net&lt;/code&gt; 初始化网络：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int initr_net(void)
{
...
    eth_initialize();
...
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int eth_initialize(void)
{
    int num_devices = 0;

    eth_devices = NULL;
    eth_current = NULL;
    eth_common_init();
    /*
     * If board-specific initialization exists, call it.
     * If not, call a CPU-specific one
     */
    if (board_eth_init != __def_eth_init) {
        if (board_eth_init(gd-&amp;gt;bd) &amp;lt; 0)
            printf(&quot;Board Net Initialization Failed\n&quot;);
    } else if (cpu_eth_init != __def_eth_init) {
        if (cpu_eth_init(gd-&amp;gt;bd) &amp;lt; 0)
            printf(&quot;CPU Net Initialization Failed\n&quot;);
    } else {
        printf(&quot;Net Initialization Skipped\n&quot;);
    }
    if (!eth_devices) {
        puts(&quot;No ethernet found.\n&quot;);
        bootstage_error(BOOTSTAGE_ID_NET_ETH_START);
    } else {
        ...
        eth_current = dev;
        ...
    }
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_initialize()&lt;/code&gt; 中，会初始化网络地址、参数(&lt;code class=&quot;highlighter-rouge&quot;&gt;eth_common_init()&lt;/code&gt;)，接着进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;board_eth_init()&lt;/code&gt; 注册网络设备，并给 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_current&lt;/code&gt; 赋值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int board_eth_init(bd_t *bis)
{
...
rv = cpsw_register(&amp;amp;cpsw_data);
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int cpsw_register(struct cpsw_platform_data *data)
{       

  eth_register(dev);
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int eth_register(struct eth_device *dev)
{
...
  eth_devices = dev;
  eth_current = dev;
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以后对网卡的操作都会直接调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_current&lt;/code&gt;。如 ping 操作最终会沿着函数调用链 ： &lt;code class=&quot;highlighter-rouge&quot;&gt;do_ping()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;net_loop()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ping_start()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ping_send()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arp_request()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arp_raw_request()&lt;/code&gt;-&amp;gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;net_send_packet()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;eth_send()&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;eth_current-&amp;gt;send&lt;/code&gt; 进行发包。&lt;/p&gt;

&lt;p&gt;注： 网卡的接口主要是收发，以及一些配置或特殊功能，现在都是通过U_BOOT_DRIVER 进行封装的，协议栈（net/net.c）会主动调用网卡接口。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;6.4.2. 串口&lt;/h4&gt;
&lt;p&gt;uboot 启动阶段会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;initr_serial&lt;/code&gt; 初始化串口终端，初始化函数调用链如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;initr_serial&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serial_initialize&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serial_init&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serial_find_console_or_panic&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void serial_find_console_or_panic(void)
{
  ...  
    if (!uclass_get_device_by_of_offset(UCLASS_SERIAL, node,
                    &amp;amp;dev)) {
      gd-&amp;gt;cur_serial_dev = dev;
    return;
    }
  ...
    if (node &amp;gt; 0 &amp;amp;&amp;amp;
    !lists_bind_fdt(gd-&amp;gt;dm_root, blob, node, &amp;amp;dev)) {
    if (!device_probe(dev)) {
        gd-&amp;gt;cur_serial_dev = dev;
        return;
    }
  ...
    if (!uclass_get_device_by_seq(UCLASS_SERIAL, INDEX, &amp;amp;dev) ||
       !uclass_get_device(UCLASS_SERIAL, INDEX, &amp;amp;dev) ||
       (!uclass_first_device(UCLASS_SERIAL, &amp;amp;dev) &amp;amp;&amp;amp; dev)) {
       gd-&amp;gt;cur_serial_dev = dev;
       return;
    }
...    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;串口驱动使用了&lt;strong&gt;方式 B&lt;/strong&gt; 声明设备结构体，在使用宏 &lt;code class=&quot;highlighter-rouge&quot;&gt;U_BOOT_DRIVER&lt;/code&gt; 定义设备结构体变量时，会给赋给设备 &lt;code class=&quot;highlighter-rouge&quot;&gt;.id=UCLASS_SERIAL&lt;/code&gt; ， 然后初始化串口时会调用到 &lt;code class=&quot;highlighter-rouge&quot;&gt;uclass_add()&lt;/code&gt; ，而这个函数会根据 id 去找设备结构体变量，然后将该设备添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;uc-&amp;gt;dev_head&lt;/code&gt; 和相关链表链表，并最后把设备指针传给 &lt;code class=&quot;highlighter-rouge&quot;&gt;gd-&amp;gt;cur_serial_dev&lt;/code&gt;。以后 uboot 使用串口进行收发包都是调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gd-&amp;gt;cur_serial_dev&lt;/code&gt; 进行的。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;6.4.3. 其他&lt;/h4&gt;

&lt;p&gt;其他外设大多类似，基本要么使用&lt;strong&gt;方式 A&lt;/strong&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;init_sequence_r[]&lt;/code&gt; 中的初始化函数进行配置的，同时驱动自己还需要提供一个接口进行设备注册；或者使用&lt;strong&gt;方式 B&lt;/strong&gt; 定义设备结构体，然后由 uboot 根据设备 ID 找到对应的结构体。两种方法最终都是要把设备驱动和 gd 全局变量关联起来。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;6.5. 设备树&lt;/h3&gt;

&lt;p&gt;dts，fdt&lt;br /&gt;
(待补充)&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;6.6. 小结&lt;/h3&gt;

&lt;p&gt;uboot 的驱动框架相对于 linux driver 来说很简单，但是相对一般裸板系统(以及 RTOS) 来说还是复杂些。&lt;/p&gt;

&lt;p&gt;首先，uboot 的驱动实现和裸板系统的驱动类似，都是直接对设备寄存器、存储空间进行操作，所有的功能都要自己实现，不似 linux 已经提供了现成的同步、互斥接口，也不需要考虑内存申请、释放、地址转换等问题，可以说都很原始；&lt;/p&gt;

&lt;p&gt;其次，虽然 uboot 的驱动实现很简单，但是使用方法和裸板驱动还是不同的，常见的裸板（包括 RTOS）驱动程序都是直接将底层操作接口暴露给上层应用，而 uboot 却对这些接口进行了封装，针对多平台的外设使用简化了使用复杂度：通过结构体将驱动操作接口和设备的全局变量（比如网卡相关全局变量为 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_current&lt;/code&gt;）关联到一起，上层应用只要知道这个全局变量就可以进行设备操作，BSP 工程师要做的就是实现驱动并且在 uboot 初始化外设时将驱动接口和这个全局变量关联起来。&lt;/p&gt;

&lt;p&gt;再次，uboot 的驱动还利用了 section 特性，将很多驱动声明在一堆连续的 section 区（如上所述，通过宏 &lt;code class=&quot;highlighter-rouge&quot;&gt;U_BOOT_DRIVER()&lt;/code&gt; 将驱动结构体放到段 &lt;code class=&quot;highlighter-rouge&quot;&gt;.u_boot_list_2_driver_2_*&lt;/code&gt;），后续如果要使用这些驱动，则只需要知道驱动名（如网卡 eth_cpsw）。&lt;/p&gt;

&lt;p&gt;最后，uboot 的驱动框架是很简单的，既要兼顾多种外设、多种架构，但又要降低驱动的实现难度，提高驱动的执行效率，所以它的框架是针对功能性和复杂度的折中实现。而 uboot 不同设备驱动在具体实现时采用的框架流程并没有统一，不同类型有不同的执行套路，比较烦人。&lt;/p&gt;

</description>
				<pubDate>Sun, 03 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/uboot%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0</link>
				<guid isPermaLink="true">/study-notes/2016/07/uboot%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0</guid>
			</item>
		
			<item>
				<title>Uboot的网络</title>
				<description>&lt;h1 id=&quot;section&quot;&gt;网络协议栈&lt;/h1&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;net
        &lt;ul&gt;
          &lt;li&gt;7.1. 协议栈主循环&lt;/li&gt;
          &lt;li&gt;7.2. 协议栈和驱动&lt;/li&gt;
          &lt;li&gt;7.3. ping&lt;/li&gt;
          &lt;li&gt;7.4. tftp&lt;/li&gt;
          &lt;li&gt;7.5. 小结&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&quot;net&quot;&gt;7. net&lt;/h2&gt;

&lt;p&gt;uboot 支持 tcp/ip 网络协议，但是作为一个 bootloader 它并没有把协议栈作为一个后台线程长时间运行，而是在使用到网络功能时才会初始化协议栈、使用网络功能。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;7.1. 协议栈主循环&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;net_loop&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;net/net.c&lt;/code&gt;） 是网络协议栈的主循环，所有的网络操作最终都会进入这里。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int net_loop(enum proto_t protocol)
{
   ...
    if (eth_is_on_demand_init() || protocol != NETCONS) {
        eth_halt();
        eth_set_current();
        ret = eth_init();
        if (ret &amp;lt; 0) {
            eth_halt();
            return ret;
        }
    } else {
        eth_init_state_only();
    }
restart:
...
    switch (net_check_prereq(protocol)) {
    case 1:
        /* network not configured */
        eth_halt();
        return -ENODEV;

    case 2:
        /* network device not configured */
        break;

    case 0:
        net_dev_exists = 1;
        net_boot_file_size = 0;
        switch (protocol) {
        case TFTPGET:
#ifdef CONFIG_CMD_TFTPPUT
        case TFTPPUT:
#endif
            /* always use ARP to get server ethernet address */
            tftp_start(protocol);
            break;
#ifdef CONFIG_CMD_TFTPSRV
        case TFTPSRV:
            tftp_start_server();
            break;
#endif
#if defined(CONFIG_CMD_DHCP)
        case DHCP:
            bootp_reset();
            net_ip.s_addr = 0;
            dhcp_request();     /* Basically same as BOOTP */
            break;
#endif

        case BOOTP:
            bootp_reset();
            net_ip.s_addr = 0;
            bootp_request();
            break;

#if defined(CONFIG_CMD_RARP)
        case RARP:
            rarp_try = 0;
            net_ip.s_addr = 0;
            rarp_request();
            break;
#endif
#if defined(CONFIG_CMD_PING)
        case PING:
            ping_start();
            break;
#endif
#if defined(CONFIG_CMD_NFS)
        case NFS:
            nfs_start();
            break;
#endif
#if defined(CONFIG_CMD_CDP)
        case CDP:
            cdp_start();
            break;
#endif
#if defined(CONFIG_NETCONSOLE) &amp;amp;&amp;amp; !(CONFIG_SPL_BUILD)
        case NETCONS:
            nc_start();
            break;
#endif
#if defined(CONFIG_CMD_SNTP)
        case SNTP:
            sntp_start();
            break;
#endif
#if defined(CONFIG_CMD_DNS)
        case DNS:
            dns_start();
            break;
#endif
#if defined(CONFIG_CMD_LINK_LOCAL)
        case LINKLOCAL:
            link_local_start();
            break;
#endif
        default:
            break;
        }

        break;
    }

#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
#if defined(CONFIG_SYS_FAULT_ECHO_LINK_DOWN)    &amp;amp;&amp;amp; \
    defined(CONFIG_STATUS_LED)          &amp;amp;&amp;amp; \
    defined(STATUS_LED_RED)
    /*
     * Echo the inverted link state to the fault LED.
     */
    if (miiphy_link(eth_get_dev()-&amp;gt;name, CONFIG_SYS_FAULT_MII_ADDR))
        status_led_set(STATUS_LED_RED, STATUS_LED_OFF);
    else
        status_led_set(STATUS_LED_RED, STATUS_LED_ON);
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
#ifdef CONFIG_USB_KEYBOARD
    net_busy_flag = 1;
#endif

    /*
     *  Main packet reception loop.  Loop receiving packets until
     *  someone sets `net_state&#39; to a state that terminates.
     */
    for (;;) {
        WATCHDOG_RESET();
#ifdef CONFIG_SHOW_ACTIVITY
        show_activity(1);
#endif
        if (arp_timeout_check() &amp;gt; 0)
            time_start = get_timer(0);

        /*
         *  Check the ethernet for a new packet.  The ethernet
         *  receive routine will process it.
         *  Most drivers return the most recent packet size, but not
         *  errors that may have happened.
         */
        eth_rx();

        /*
         *  Abort if ctrl-c was pressed.
         */
        if (ctrlc()) {
            /* cancel any ARP that may not have completed */
            net_arp_wait_packet_ip.s_addr = 0;

            net_cleanup_loop();
            eth_halt();
            /* Invalidate the last protocol */
            eth_set_last_protocol(BOOTP);

            puts(&quot;\nAbort\n&quot;);
            /* include a debug print as well incase the debug
               messages are directed to stderr */
            debug_cond(DEBUG_INT_STATE, &quot;--- net_loop Abort!\n&quot;);
            ret = -EINTR;
            goto done;
        }

        /*
         *  Check for a timeout, and run the timeout handler
         *  if we have one.
         */
        if (time_handler &amp;amp;&amp;amp;
            ((get_timer(0) - time_start) &amp;gt; time_delta)) {
            thand_f *x;

#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
#if defined(CONFIG_SYS_FAULT_ECHO_LINK_DOWN)    &amp;amp;&amp;amp; \
    defined(CONFIG_STATUS_LED)          &amp;amp;&amp;amp; \
    defined(STATUS_LED_RED)
            /*
             * Echo the inverted link state to the fault LED.
             */
            if (miiphy_link(eth_get_dev()-&amp;gt;name,
                    CONFIG_SYS_FAULT_MII_ADDR))
                status_led_set(STATUS_LED_RED, STATUS_LED_OFF);
            else
                status_led_set(STATUS_LED_RED, STATUS_LED_ON);
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
            debug_cond(DEBUG_INT_STATE, &quot;--- net_loop timeout\n&quot;);
            x = time_handler;
            time_handler = (thand_f *)0;
            (*x)();
        }

        if (net_state == NETLOOP_FAIL)
            ret = net_start_again();

        switch (net_state) {
        case NETLOOP_RESTART:
            net_restarted = 1;
            goto restart;

        case NETLOOP_SUCCESS:
            net_cleanup_loop();
            if (net_boot_file_size &amp;gt; 0) {
                printf(&quot;Bytes transferred = %d (%x hex)\n&quot;,
                       net_boot_file_size, net_boot_file_size);
                setenv_hex(&quot;filesize&quot;, net_boot_file_size);
                setenv_hex(&quot;fileaddr&quot;, load_addr);
            }
            if (protocol != NETCONS)
                eth_halt();
            else
                eth_halt_state_only();

            eth_set_last_protocol(protocol);

            ret = net_boot_file_size;
            debug_cond(DEBUG_INT_STATE, &quot;--- net_loop Success!\n&quot;);
            goto done;

        case NETLOOP_FAIL:
            net_cleanup_loop();
            /* Invalidate the last protocol */
            eth_set_last_protocol(BOOTP);
            debug_cond(DEBUG_INT_STATE, &quot;--- net_loop Fail!\n&quot;);
            goto done;

        case NETLOOP_CONTINUE:
            continue;
        }
    }

done:
#ifdef CONFIG_USB_KEYBOARD
    net_busy_flag = 0;
#endif
#ifdef CONFIG_CMD_TFTPPUT
    /* Clear out the handlers */
    net_set_udp_handler(NULL);
    net_set_icmp_handler(NULL);
#endif
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面的代码可以看出 &lt;br /&gt;
uboot 网络处里流程和一般的协议栈类似（如 lwip 所有的操作都是放在一个循环，在一个线程中运行）。&lt;/p&gt;

&lt;p&gt;流程可以分解为 3 步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化协议栈&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
net_init();
net_init_loop();
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;区分不同的子协议（如 ping 、 ICMP 、 arp 等）&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
case DHCP:
 ...
case PING:
 ...
case DNS:
 ...
...
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;关闭协议栈和网络设备&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
...
eth_halt();
...
net_cleanup_loop();
...
&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;7.2. 协议栈和驱动&lt;/h3&gt;

&lt;p&gt;协议栈收发数据都是通过函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_send()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_rx()&lt;/code&gt; 完成的。&lt;/p&gt;

&lt;p&gt;发包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int eth_send(void *packet, int length)                         
{                                                              
...                                   
    current = eth_get_dev();                                   
...
    ret = eth_get_ops(current)-&amp;gt;send(current, packet, length); 
    if (ret &amp;lt; 0) {                                             
        /* We cannot completely return the error at present */ 
        debug(&quot;%s: send() returned error %d\n&quot;, __func__, ret);
    }                                                          
    return ret;                                                
}                                                              

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;收包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int eth_rx(void)
{
...
    current = eth_get_dev();
...  
    for (i = 0; i &amp;lt; 32; i++) {
        ret = eth_get_ops(current)-&amp;gt;recv(current, flags, &amp;amp;packet);
        flags = 0;
        if (ret &amp;gt; 0)
            net_process_received_packet(packet, ret);
        if (ret &amp;gt;= 0 &amp;amp;&amp;amp; eth_get_ops(current)-&amp;gt;free_pkt)
            eth_get_ops(current)-&amp;gt;free_pkt(current, packet, ret);
        if (ret &amp;lt;= 0)
            break;
    }
...
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两者最终都是调用实际的驱动函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;cpsw_send()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;cpsw_recv()&lt;/code&gt; 进行收发包&lt;/p&gt;

&lt;h3 id=&quot;ping&quot;&gt;7.3. ping&lt;/h3&gt;

&lt;p&gt;uboot 网络支持多种操作，但是都有一个特点就是必须 uboot 首先发起操作，然后相应对端的操作，并不能像一般的系统那样时时刻刻接受对端的网络请求。&lt;/p&gt;

&lt;p&gt;ping 的实现也只是向外发送 ping 包，然后接收响应，并不会响应对端发起的 ping 操作。&lt;/p&gt;

&lt;p&gt;ping 是作为一个命令（&lt;code class=&quot;highlighter-rouge&quot;&gt;ping&lt;/code&gt;）存在于 uboot 的，它的函数实现是 &lt;code class=&quot;highlighter-rouge&quot;&gt;do_ping()&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/net.c&lt;/code&gt;） ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int do_ping(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
...
    if (net_loop(PING) &amp;lt; 0) {
        printf(&quot;ping failed; host %s is not alive\n&quot;, argv[1]);
        return CMD_RET_FAILURE;
    }
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;net_loop()&lt;/code&gt;  ，首先向外发 ping 包 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
switch (protocol) {
    ...
    case PING:
        ping_start();
        break;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用 ping 的发包函数&lt;br /&gt;
```&lt;br /&gt;
void ping_start(void)&lt;br /&gt;
{&lt;br /&gt;
    printf(“Using %s device\n”, eth_get_name());&lt;br /&gt;
    net_set_timeout_handler(10000UL, ping_timeout_handler);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ping_send(); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int ping_send(void)
{
...
    arp_request();
    return 1;   /* waiting */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arp_request()&lt;/code&gt; 最终会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_send()&lt;/code&gt; 调用网卡驱动发送数据包。&lt;/p&gt;

&lt;p&gt;接下来，&lt;code class=&quot;highlighter-rouge&quot;&gt;net_loop()&lt;/code&gt; 会等待对端发送的响应包，并进行处理：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (;;) {
    ...
    eth_rx();
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;eth_rx()&lt;/code&gt; 调用网卡驱动，而网卡驱动会调用函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;net_process_received_packet()&lt;/code&gt; 处理协议栈相关的操作，此处就是执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ping_receive()&lt;/code&gt; 完成 ping 操作的&lt;strong&gt;收&lt;/strong&gt;阶段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
    struct icmp_hdr *icmph = (struct icmp_hdr *)&amp;amp;ip-&amp;gt;udp_src;
    struct in_addr src_ip;
    int eth_hdr_size;

    switch (icmph-&amp;gt;type) {
    case ICMP_ECHO_REPLY:
        src_ip = net_read_ip((void *)&amp;amp;ip-&amp;gt;ip_src);
        if (src_ip.s_addr == net_ping_ip.s_addr)
            net_set_state(NETLOOP_SUCCESS);
        return;
    ...
/*  default:
        return;*/
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;net_set_state()&lt;/code&gt; 告知 &lt;code class=&quot;highlighter-rouge&quot;&gt;net_loop()&lt;/code&gt; ping 操作成功，否则 ping 失败，即网络有问题。&lt;/p&gt;

&lt;h3 id=&quot;tftp&quot;&gt;7.4. tftp&lt;/h3&gt;

&lt;p&gt;tftp 分两部分：向服务器发送请求和从服务器接收数据，所以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;net_loop()&lt;/code&gt; 中 tftp 协议有两组判断条件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int net_loop(enum proto_t protocol)
{
    ...
        case TFTPGET:
#ifdef CONFIG_CMD_TFTPPUT
        case TFTPPUT:
#endif
            /* always use ARP to get server ethernet address */
            tftp_start(protocol);
            break;
    ...

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发送请求（&lt;code class=&quot;highlighter-rouge&quot;&gt;TFTPGET&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;TFTPPUT&lt;/code&gt;），向对端发送 tftp 请求，比如 GET 和 PUT ，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tftp_start()&lt;/code&gt; 发送请求报文：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void tftp_start(enum proto_t protocol)
{
...
    net_set_udp_handler(tftp_handler);
...
    tftp_send();
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;net_set_udp_handler()&lt;/code&gt; 会注册 &lt;code class=&quot;highlighter-rouge&quot;&gt;tftp_handler()&lt;/code&gt; 到钩子函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;static rxhand_f *udp_packet_handler;&lt;/code&gt;，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;tftp_handler()&lt;/code&gt; 会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tftp_complete()&lt;/code&gt; 检查接收文件是否结束。&lt;/p&gt;

&lt;p&gt;接下来 &lt;code class=&quot;highlighter-rouge&quot;&gt;net_loop()&lt;/code&gt; 会循环调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth_rx()&lt;/code&gt; 接收数据包，直到所有数据都收完（钩子函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;udp_packet_handler&lt;/code&gt; 会不断的检查已收到的文件长度和实际文件长度是否一直）。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;7.5. 小结&lt;/h3&gt;

&lt;p&gt;uboot 的网络协议栈可以说是麻雀虽小肝胆俱全，网络协议栈所需要的功能它基本都实现了，比如 ping 、 tftp 、tftp server 、DHCP 、 bootp 、 arp/rarp 、DNS 等，它主要侧重于功能的实现，对实时性、并发性等要求不高，所以都是由用户输入命令主动发起操作，并且是单线程操作。&lt;/p&gt;

</description>
				<pubDate>Sun, 03 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/uboot%E7%9A%84%E7%BD%91%E7%BB%9C</link>
				<guid isPermaLink="true">/study-notes/2016/07/uboot%E7%9A%84%E7%BD%91%E7%BB%9C</guid>
			</item>
		
			<item>
				<title>Uboot文件系统框架概述</title>
				<description>&lt;h1 id=&quot;section&quot;&gt;文件系统&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;8. 文件系统&lt;/h2&gt;

&lt;p&gt;uboot 支持多种常见的文件系统，包括 fat 、 ext 、 jffs2 、 reiserfs 、 yaffs2 、 zfs 、ubifs 、cbfs 、cramfs 等。&lt;/p&gt;

&lt;p&gt;uboot 的文件系统有两种接口，一种是 &lt;code class=&quot;highlighter-rouge&quot;&gt;fs_*&lt;/code&gt; 一种是具体的文件系统的接口，比如 yaffs2 的接口就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;yaffs_*&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fs_*&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fs_*&lt;/code&gt; 实际上是对各种文件系统的封装，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;fs/fs.c&lt;/code&gt; 里定义了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;fstype&lt;/code&gt; 类型的数组：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static struct fstype_info fstypes[] = {
#ifdef CONFIG_FS_FAT
    {
        .fstype = FS_TYPE_FAT,
        .name = &quot;fat&quot;,
        .null_dev_desc_ok = false,
        .probe = fat_set_blk_dev,
        .close = fat_close,
        .ls = file_fat_ls,
        .exists = fat_exists,
        .size = fat_size,
        .read = fat_read_file,
#ifdef CONFIG_FAT_WRITE
        .write = file_fat_write,
#else
        .write = fs_write_unsupported,
#endif
        .uuid = fs_uuid_unsupported,
    },
#endif
#ifdef CONFIG_FS_EXT4
    {
        .fstype = FS_TYPE_EXT,
        .name = &quot;ext4&quot;,
        .null_dev_desc_ok = false,
        .probe = ext4fs_probe,
        .close = ext4fs_close,
        .ls = ext4fs_ls,
        .exists = ext4fs_exists,
        .size = ext4fs_size,
        .read = ext4_read_file,
#ifdef CONFIG_CMD_EXT4_WRITE
        .write = ext4_write_file,
#else
        .write = fs_write_unsupported,
#endif
        .uuid = ext4fs_uuid,
    },
#endif
#ifdef CONFIG_SANDBOX
    {
        .fstype = FS_TYPE_SANDBOX,
        .name = &quot;sandbox&quot;,
        .null_dev_desc_ok = true,
        .probe = sandbox_fs_set_blk_dev,
        .close = sandbox_fs_close,
        .ls = sandbox_fs_ls,
        .exists = sandbox_fs_exists,
        .size = sandbox_fs_size,
        .read = fs_read_sandbox,
        .write = fs_write_sandbox,
        .uuid = fs_uuid_unsupported,
    },
#endif
#ifdef CONFIG_CMD_UBIFS
    {
        .fstype = FS_TYPE_UBIFS,
        .name = &quot;ubifs&quot;,
        .null_dev_desc_ok = true,
        .probe = ubifs_set_blk_dev,
        .close = ubifs_close,
        .ls = ubifs_ls,
        .exists = ubifs_exists,
        .size = ubifs_size,
        .read = ubifs_read,
        .write = fs_write_unsupported,
        .uuid = fs_uuid_unsupported,
    },
#endif
    {
        .fstype = FS_TYPE_ANY,
        .name = &quot;unsupported&quot;,
        .null_dev_desc_ok = true,
        .probe = fs_probe_unsupported,
        .close = fs_close_unsupported,
        .ls = fs_ls_unsupported,
        .exists = fs_exists_unsupported,
        .size = fs_size_unsupported,
        .read = fs_read_unsupported,
        .write = fs_write_unsupported,
        .uuid = fs_uuid_unsupported,
    },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;数组内包含了几种文件系统：fat 、 ext4 、ubifs 和实验用的 sandbox，而 fs 的接口函数，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;fs_read()&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;fs_write()&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;fs_ls&lt;/code&gt; 等，在执行操作时都是根据文件系统的类型调用不同文件系统接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int fs_read(const char *filename, ulong addr, loff_t offset, loff_t len,
	    loff_t *actread)
{
	struct fstype_info *info = fs_get_info(fs_type);
...
	ret = info-&amp;gt;read(filename, buf, offset, len, actread);
...
	fs_close();

	return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其它操作也类似，首先根据文件系统类型（&lt;code class=&quot;highlighter-rouge&quot;&gt;fs_type&lt;/code&gt;）获取到具体某个文件系统操作的数据结构（&lt;code class=&quot;highlighter-rouge&quot;&gt;fs_get_info()&lt;/code&gt;），然后调用指定的操作（&lt;code class=&quot;highlighter-rouge&quot;&gt;info-&amp;gt;read()&lt;/code&gt;），最后关闭文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;fs_close()&lt;/code&gt;，&lt;strong&gt;uboot 的文件系统操作都是一次性的，即将open-&amp;gt;ops-&amp;gt;close 集成为一个 ops 操作函数&lt;/strong&gt;）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;具体的文件系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体的文件系统就比较简单，都提供 read 、 write 、 ls 接口（如上所述，uboot 不提供也不需要提供单独的 open 、 close 接口）。如 jffs2 的 read 接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Load a file from flash into memory. fname can be a full path */
u32
jffs2_1pass_load(char *dest, struct part_info * part, const char *fname)
{

	struct b_lists *pl;
	long ret = 1;
	u32 inode;

	if (! (pl  = jffs2_get_list(part, &quot;load&quot;)))
		return 0;

	if (! (inode = jffs2_1pass_search_inode(pl, fname, 1))) {
		putstr(&quot;load: Failed to find inode\r\n&quot;);
		return 0;
	}

	/* Resolve symlinks */
	if (! (inode = jffs2_1pass_resolve_inode(pl, inode))) {
		putstr(&quot;load: Failed to resolve inode structure\r\n&quot;);
		return 0;
	}

	if ((ret = jffs2_1pass_read_inode(pl, inode, dest)) &amp;lt; 0) {
		putstr(&quot;load: Failed to read inode\r\n&quot;);
		return 0;
	}

	DEBUGF (&quot;load: loaded &#39;%s&#39; to 0x%lx (%ld bytes)\n&quot;, fname,
				(unsigned long) dest, ret);
	return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fat 的 write 接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int file_fat_write(const char *filename, void *buffer, loff_t offset,
		   loff_t maxsize, loff_t *actwrite)
{
	if (offset != 0) {
		printf(&quot;Error: non zero offset is currently not supported.\n&quot;);
		return -1;
	}

	printf(&quot;writing %s\n&quot;, filename);
	return do_fat_write(filename, buffer, maxsize, actwrite);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ext4 的 ls 接口 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int ext4fs_ls(const char *dirname)
{
	struct ext2fs_node *dirnode;
	int status;

	if (dirname == NULL)
		return 0;

	status = ext4fs_find_file(dirname, &amp;amp;ext4fs_root-&amp;gt;diropen, &amp;amp;dirnode,
				  FILETYPE_DIRECTORY);
	if (status != 1) {
		printf(&quot;** Can not find directory. **\n&quot;);
		return 1;
	}

	ext4fs_iterate_dir(dirnode, NULL, NULL, NULL);
	ext4fs_free_node(dirnode, &amp;amp;ext4fs_root-&amp;gt;diropen);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;uboot 的文件系统部分基本就是这两类，本身并不复杂，麻烦在于具体的文件系统实现：文件系统逻辑和存储设备操作接口。（此不赘述）&lt;/p&gt;

</description>
				<pubDate>Sun, 03 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/uboot%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0</link>
				<guid isPermaLink="true">/study-notes/2016/07/uboot%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0</guid>
			</item>
		
			<item>
				<title>Uboot的shell</title>
				<description>&lt;h1 id=&quot;uboot-shell-&quot;&gt;uboot shell 命令&lt;/h1&gt;

&lt;h2 id=&quot;uboot-shell--1&quot;&gt;4. uboot shell 命令的实现&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;4.1. 添加命令&lt;/h3&gt;

&lt;p&gt;以命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot&lt;/code&gt; 为例（&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/bootm.c&lt;/code&gt;），添加该命令使用了下面的语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;U_BOOT_CMD(
    boot,   1,  1,  do_bootd,
    &quot;boot default, i.e., run &#39;bootcmd&#39;&quot;,
    &quot;&quot;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段语句可以这么理解：给 uboot 添加了一条 shell 命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot&lt;/code&gt;，它的作用是引导、启动操作系统(&lt;code class=&quot;highlighter-rouge&quot;&gt;boot default, i.e., run &#39;bootcmd&#39;&lt;/code&gt;)，实现命令的函数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;do_bootd&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;之所以这么一条语句就可以完成添加 shell 命令，可以参考 U_BOOT_CMD 的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)      \
    U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \
    ll_entry_declare(cmd_tbl_t, _name, cmd) =           \
        U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,  \
                        _usage, _help, _comp);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define ll_entry_declare(_type, _name, _list)               \
    _type _u_boot_list_2_##_list##_2_##_name __aligned(4)       \
            __attribute__((unused,              \
            section(&quot;.u_boot_list_2_&quot;#_list&quot;_2_&quot;#_name)))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,      \
                _usage, _help, _comp)           \
        { #_name, _maxargs, _rep, _cmd, _usage,         \
            _CMD_HELP(_help) _CMD_COMPLETE(_comp) }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# define _CMD_HELP(x) x,
# define _CMD_COMPLETE(x) x,
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过逐层解析宏 &lt;code class=&quot;highlighter-rouge&quot;&gt;U_BOOT_CMD&lt;/code&gt;，最终会得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd_tbl_t _u_boot_list_2_cmd_2_boot __aligned(4) __attribute__((unused, section(&quot;.u_boot_list_2_cmd_2_boot&quot;))) = {
        `boot`,
        1,
        1,
        do_bootd,
        &quot;boot default, i.e., run &#39;bootcmd&#39;&quot;,
        &quot;&quot;,
        };


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 u-boot.lds 中会链接 .u_boot_list_2_cmd_2_boot ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;. = ALIGN(4);
.u_boot_list : {
 KEEP(*(SORT(.u_boot_list*)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：其中 SORT 会按照名称的的顺序进行链接。&lt;/p&gt;

&lt;p&gt;cmd_tbl_t 定义如下(成员变量 complete 暂不讨论)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct cmd_tbl_s    cmd_tbl_t;
struct cmd_tbl_s {
    char        *name;      /* Command Name         */
    int         maxargs;    /* maximum number of arguments  */
    int         repeatable; /* autorepeat allowed?      */
                    /* Implementation function  */
    int         (*cmd)(struct cmd_tbl_s *, int, int, char * const []);
    char        *usage;     /* Usage message    (short) */
#ifdef  CONFIG_SYS_LONGHELP
    char        *help;      /* Help  message    (long)  */
#endif
#ifdef CONFIG_AUTO_COMPLETE
    /* do auto completion on the arguments */
    int     (*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);
#endif
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;综上，  &lt;code class=&quot;highlighter-rouge&quot;&gt;U_BOOT_CMD(...)&lt;/code&gt; 实际上是定义了一个结构体变量，这个结构体定义了 uboot 的 shell 命令要用到的信息，并且这个结构体变量是保存在指定的位置（&lt;code class=&quot;highlighter-rouge&quot;&gt;section(&quot;.u_boot_list_2_cmd_2_boot&quot;)&lt;/code&gt;)。 uboot 运行时会主动在该 section 寻找命令并执行。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;4.2. 执行命令&lt;/h3&gt;

&lt;p&gt;uboot 的 shell 入口是 &lt;code class=&quot;highlighter-rouge&quot;&gt;common/board_r.c&lt;/code&gt; 的 run_main_loop() :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int run_main_loop(void)
{
#ifdef CONFIG_SANDBOX
    sandbox_main_loop_init();
#endif
    /* main_loop() can return to retry autoboot, if so just run it again */
    for (;;)
        main_loop();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main_loop()&lt;/code&gt; 会重复执行，处理输入的命令&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;common/main.c&lt;/code&gt; 的 main_loop ：&lt;br /&gt;
```&lt;br /&gt;
/* We come here after U-Boot is initialised and ready to process commands */&lt;br /&gt;
void main_loop(void)&lt;br /&gt;
{&lt;br /&gt;
    const char *s;&lt;/p&gt;

&lt;p&gt;…&lt;br /&gt;
    cli_init();&lt;br /&gt;
…&lt;br /&gt;
    s = bootdelay_process();&lt;br /&gt;
    if (cli_process_fdt(&amp;amp;s))&lt;br /&gt;
        cli_secure_boot_cmd(s);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;autoboot_command(s);

cli_loop(); ... } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;cli_loop()&lt;/code&gt; 是执行命令的具体函数 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void cli_loop(void)
{
...
    parse_file_outer();
    /* This point is never reached */
    for (;;);
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;parse_file_outer()&lt;/code&gt; 会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;parse_stream_outer()&lt;/code&gt; 解析输入的命令并调用 run_list() 执行命令 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int parse_stream_outer(struct in_str *inp, int flag)
{
...
    do {
        ...
            run_list(ctx.list_head);
...
    /* loop on syntax errors, return on EOF */
    } while (rcode != -1 &amp;amp;&amp;amp; !(flag &amp;amp; FLAG_EXIT_FROM_LOOP) &amp;amp;&amp;amp;
        (inp-&amp;gt;peek != static_peek || b_peek(inp)));
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着顺着函数调用链 &lt;code class=&quot;highlighter-rouge&quot;&gt;run_list() -&amp;gt; run_list_real() -&amp;gt; run_pipe_real() -&amp;gt; cmd_process()&lt;/code&gt; uboot 进入到 cmd_process() 开始准备执行命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
                   int *repeatable, ulong *ticks)
{
    enum command_ret_t rc = CMD_RET_SUCCESS;
    cmd_tbl_t *cmdtp;

    /* Look up command in command table */
    cmdtp = find_cmd(argv[0]);
    if (cmdtp == NULL) {
        printf(&quot;Unknown command &#39;%s&#39; - try &#39;help&#39;\n&quot;, argv[0]);
        return 1;
    }

    /* found - check max args */
    if (argc &amp;gt; cmdtp-&amp;gt;maxargs)
        rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
    /* avoid &quot;bootd&quot; recursion */
    else if (cmdtp-&amp;gt;cmd == do_bootd) {
        if (flag &amp;amp; CMD_FLAG_BOOTD) {
            puts(&quot;&#39;bootd&#39; recursion detected\n&quot;);
            rc = CMD_RET_FAILURE;
        } else {
            flag |= CMD_FLAG_BOOTD;
        }
    }
#endif

    /* If OK so far, then do the command */
    if (!rc) {
        if (ticks)
            *ticks = get_timer(0);
        rc = cmd_call(cmdtp, flag, argc, argv);
        if (ticks)
            *ticks = get_timer(*ticks);
        *repeatable &amp;amp;= cmdtp-&amp;gt;repeatable;
    }
    if (rc == CMD_RET_USAGE)
        rc = cmd_usage(cmdtp);
    return rc;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;find_cmd()&lt;/code&gt; 用来在保存命令的 &lt;code class=&quot;highlighter-rouge&quot;&gt;u_boot_list*&lt;/code&gt; 段内寻找命令对应的结构体变量，然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_call()&lt;/code&gt; 调用结构体变量对应的函数，到此命令执行完成。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;4.3. 命令解析&lt;/h3&gt;

&lt;p&gt;命令解析有三部分：输入命令、找到命令、执行命令。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;4.3.1. 输入命令&lt;/h4&gt;

&lt;p&gt;uboot shell 的命令都是通过串口输入的，s用户输入字符串后会由 uboot 对字符串进行解析，最终获得命令、命令参数。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;4.3.2. 找到命令&lt;/h4&gt;

&lt;p&gt;通过串口输入获取到命令名称和命令参数后，要在 section .u_boot_list_2_cmd_2* 找到命令的结构体变量，根据结构体变量调用命令背后的函数。&lt;/p&gt;

&lt;p&gt;寻找命令的函数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_tbl_t *find_cmd()&lt;/code&gt; ，函数返回了对应的命令结构体变量 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd_tbl_t *find_cmd(const char *cmd)
{
    cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
    const int len = ll_entry_count(cmd_tbl_t, cmd);
    return find_cmd_tbl(cmd, start, len);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define ll_entry_start(_type, _list)                    \
({                                  \
    static char start[0] __aligned(4) __attribute__((unused,    \
        section(&quot;.u_boot_list_2_&quot;#_list&quot;_1&quot;)));         \
    (_type *)&amp;amp;start;                        \
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define ll_entry_count(_type, _list)                    \
    ({                              \
        _type *start = ll_entry_start(_type, _list);        \
        _type *end = ll_entry_end(_type, _list);        \
        unsigned int _ll_result = end - start;          \
        _ll_result;                     \
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define ll_entry_end(_type, _list)                  \
({                                  \
    static char end[0] __aligned(4) __attribute__((unused,      \
        section(&quot;.u_boot_list_2_&quot;#_list&quot;_3&quot;)));         \
    (_type *)&amp;amp;end;                          \
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而命令的结构体变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;.u_boot_list_2_*_2*&lt;/code&gt; 正好位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;.u_boot_list_2_&quot;#_list&quot;_1&quot;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;.u_boot_list_2_&quot;#_list&quot;_3&quot;&lt;/code&gt; 之间，这样就获取到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;.u_boot_list_2_*_2*&lt;/code&gt; 的长度，然后调用函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;find_cmd_tbl()&lt;/code&gt; 遍历该 section 、寻找命令对应的结构体变量并返回给 shell。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)
{
...
    for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
        if (strncmp(cmd, cmdtp-&amp;gt;name, len) == 0) {
            if (len == strlen(cmdtp-&amp;gt;name))
                return cmdtp;   /* full match */

            cmdtp_temp = cmdtp; /* abbreviated command ? */
            n_found++;
        }
    }
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;4.3.3. 执行命令&lt;/h4&gt;

&lt;p&gt;cmd_process() 调用 cmd_call() 执行命令，很简单就是直接调用命令结构体变量的成员函数 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
   ...
    result = (cmdtp-&amp;gt;cmd)(cmdtp, flag, argc, argv);
   ....
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
				<pubDate>Sat, 02 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/uboot%E7%9A%84shell</link>
				<guid isPermaLink="true">/study-notes/2016/07/uboot%E7%9A%84shell</guid>
			</item>
		
			<item>
				<title>Uboot最重要的全局变量gd</title>
				<description>&lt;h1 id=&quot;gd&quot;&gt;gd&lt;/h1&gt;

&lt;h2 id=&quot;gd-1&quot;&gt;8. gd&lt;/h2&gt;

&lt;p&gt;gd 是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;gd_t&lt;/code&gt; 类型的结构体变量，在 uboot 阶段地址保存在寄存器 &lt;code class=&quot;highlighter-rouge&quot;&gt;r9&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm (&quot;r9&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gd_t&lt;/code&gt; 结构体定义在 &lt;code class=&quot;highlighter-rouge&quot;&gt;include/asm-generic/global_data.h&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct global_data {
    bd_t *bd;
    unsigned long flags;
    unsigned int baudrate;
    unsigned long cpu_clk;  /* CPU clock in Hz!     */
    unsigned long bus_clk;
    /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */
    unsigned long pci_clk;
    unsigned long mem_clk;
#if defined(CONFIG_LCD) || defined(CONFIG_VIDEO)
    unsigned long fb_base;  /* Base address of framebuffer mem */
#endif
#if defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)
    unsigned long post_log_word;  /* Record POST activities */
    unsigned long post_log_res; /* success of POST test */
    unsigned long post_init_f_time;  /* When post_init_f started */
#endif
#ifdef CONFIG_BOARD_TYPES
    unsigned long board_type;
#endif
    unsigned long have_console; /* serial_init() was called */
#ifdef CONFIG_PRE_CONSOLE_BUFFER
    unsigned long precon_buf_idx;   /* Pre-Console buffer index */
#endif
    unsigned long env_addr; /* Address  of Environment struct */
    unsigned long env_valid;    /* Checksum of Environment valid? */
        unsigned long env_valid;    /* Checksum of Environment valid? */

    unsigned long ram_top;  /* Top address of RAM used by U-Boot */

    unsigned long relocaddr;    /* Start address of U-Boot in RAM */
    phys_size_t ram_size;   /* RAM size */
#ifdef CONFIG_SYS_MEM_RESERVE_SECURE
#define MEM_RESERVE_SECURE_SECURED  0x1
#define MEM_RESERVE_SECURE_MAINTAINED   0x2
#define MEM_RESERVE_SECURE_ADDR_MASK    (~0x3)
    /*
     * Secure memory addr
     * This variable needs maintenance if the RAM base is not zero,
     * or if RAM splits into non-consecutive banks. It also has a
     * flag indicating the secure memory is marked as secure by MMU.
     * Flags used: 0x1 secured
     *             0x2 maintained
     */
    phys_addr_t secure_ram;
#endif
    unsigned long mon_len;  /* monitor len */
    unsigned long irq_sp;       /* irq stack pointer */
    unsigned long start_addr_sp;    /* start_addr_stackpointer */
    unsigned long reloc_off;
    struct global_data *new_gd; /* relocated global data */

#ifdef CONFIG_DM
    struct udevice  *dm_root;   /* Root instance for Driver Model */
    struct udevice  *dm_root_f; /* Pre-relocation root instance */
    struct list_head uclass_root;   /* Head of core tree */
#endif
#ifdef CONFIG_TIMER
    struct udevice  *timer; /* Timer instance for Driver Model */
#endif

    const void *fdt_blob;   /* Our device tree, NULL if none */
    void *new_fdt;      /* Relocated FDT */
    unsigned long fdt_size; /* Space reserved for relocated FDT */
    struct jt_funcs *jt;        /* jump table */
    char env_buf[32];   /* buffer for getenv() before reloc. */
#ifdef CONFIG_TRACE
    void        *trace_buff;    /* The trace buffer */
#endif
#if defined(CONFIG_SYS_I2C)
    int     cur_i2c_bus;    /* current used i2c bus */
#endif
#ifdef CONFIG_SYS_I2C_MXC
    void *srdata[10];
#endif
    unsigned long timebase_h;
        unsigned long timebase_l;
#ifdef CONFIG_SYS_MALLOC_F_LEN
    unsigned long malloc_base;  /* base address of early malloc() */
    unsigned long malloc_limit; /* limit address */
    unsigned long malloc_ptr;   /* current address */
#endif
#ifdef CONFIG_PCI
    struct pci_controller *hose;    /* PCI hose for early use */
    phys_addr_t pci_ram_top;    /* top of region accessible to PCI */
#endif
#ifdef CONFIG_PCI_BOOTDELAY
    int pcidelay_done;
#endif
    struct udevice *cur_serial_dev; /* current serial device */
    struct arch_global_data arch;   /* architecture-specific data */
#ifdef CONFIG_CONSOLE_RECORD
    struct membuff console_out; /* console output */
    struct membuff console_in;  /* console input */
#endif
#ifdef CONFIG_DM_VIDEO
    ulong video_top;        /* Top of video frame buffer area */
    ulong video_bottom;     /* Bottom of video frame buffer area */
#endif
} gd_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从定义可以看出 gd 实际上包含了 uboot 运行过程中要使用的几乎全部的全局变量。&lt;/p&gt;

&lt;p&gt;gd 最开始是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_main&lt;/code&gt; 里初始化的(有些架构是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;board_init_f()&lt;/code&gt; 里面初始化的):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENTRY(_main)
...
/* set up gd here, outside any C code */
mov r9, r0
bl  board_init_f_init_reserve
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void board_init_f_init_reserve(ulong base)
{
    struct global_data *gd_ptr;
#ifndef _USE_MEMCPY
    int *ptr;
#endif

    /*
     * clear GD entirely and set it up.
     * Use gd_ptr, as gd may not be properly set yet.
     */

    gd_ptr = (struct global_data *)base;
    /* zero the area */
#ifdef _USE_MEMCPY
    memset(gd_ptr, &#39;\0&#39;, sizeof(*gd));
#else
    for (ptr = (int *)gd_ptr; ptr &amp;lt; (int *)(gd_ptr + 1); )
        *ptr++ = 0;
#endif
    /* set GD unless architecture did it already */
#if !defined(CONFIG_ARM)
    arch_setup_gd(gd_ptr);
#endif
    /* next alloc will be higher by one GD plus 16-byte alignment */
    base += roundup(sizeof(struct global_data), 16);

    /*
     * record early malloc arena start.
     * Use gd as it is now properly set for all architectures.
     */

#if defined(CONFIG_SYS_MALLOC_F)
    /* go down one &#39;early malloc arena&#39; */
    gd-&amp;gt;malloc_base = base;
    /* next alloc will be higher by one &#39;early malloc arena&#39; size */
    base += CONFIG_SYS_MALLOC_F_LEN;
#endif
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且随着 uboot 初始化外设、准备引导系统的过程不断的初始化自己的各个成员变量，如初始化串口时就对 &lt;code class=&quot;highlighter-rouge&quot;&gt;*cur_serial_dev&lt;/code&gt; 进行赋值。&lt;/p&gt;
</description>
				<pubDate>Sat, 02 Jul 2016 00:00:00 +0800</pubDate>
				<link>/study-notes/2016/07/uboot%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8Fgd</link>
				<guid isPermaLink="true">/study-notes/2016/07/uboot%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8Fgd</guid>
			</item>
		
	</channel>
</rss>

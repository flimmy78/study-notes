---
title: 2016-7-24-Linux的模块机制 
tags : [ Kernel , Linux ]
---

Linux Kernel 是宏内核，和微内核相对的，它的所有内核内核功能的实现都在内核之中，所以相对于微内核实现， Linux Kernel 就是一个“巨无霸”。宏内核的好处是系统运行中性能相对好，不容易受到其他代码的影响，但是缺点不够灵活，如果 Linux Kernel 完全这样做的话，那么就会出现一种情况：哪怕添加一个很小的功能，都得把整个内核重新编译、更新，而且最终的内核将会十分巨大，甚至不能满足引导系统（如 uboot）对内核镜像大小的要求。为了解决这个问题， Linux 在宏内核的基础上采用了可加载模块机制，即将 Kernel 的绝大部分功能都和核心模块编译成一个独立的内核镜像，然后如果你要给内核添加你需要的功能，那么你可以按照 Kernel 的要求规范编写模块（module），在系统启动后将 module 加载到内核空间，这样既可以保证系统的高性能和可靠性，也可以保证系统必要的灵活性，方便的增加新功能，实际上很多需要运行在内核态的功能都是以可加载模块的形式实现的，比如很多驱动程序都是以 module 的形式使用的，除此之外，还有一种使用模块的原因：厂商不愿意开放源代码而通过可加载模块规避版权限制。

Linux 的模块机制可以简单的分为：


### 1. 构建模块

linux 的模块有专门的编写规范：入口（module_init）、出口（module_exit）和声明信息，最简单的模块就包括这些：


```
/*tm.c*/

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ezio");
MODULE_DESCRIPTION("A simple Linux module");
MODULE_VERSION("0.1");

static int __init tm_init(void){
   int result = 0;

   printk(KERN_INFO "Hello Module\n");
   return 0;
}


static void __exit tm_exit(void){
   printk(KERN_INFO "Bye Module\n");
}

module_init(tm_init);
module_exit(tm_exit);
```

```
/*Makefile */
obj-m += tm.o

KERNEL_PATH := ***

all:
	make -C $(KERNEL_PATH) M=$(PWD) modules
clean:
	make -C $(KERNEL_PATH) M=$(PWD) clean
```

首先，模块使用的函数库和一般的应用程序不同，并没有使用标准库函数和系统库函数，而是用的内核函数和内核头文件，比如头文件引用的是 `module.h` ，打印使用了 `printk()` 而不是 `printf()` ；然后，模块的入口不像普通应用程序使用 `main()` ，而是 `module_init` 声明的函数，本处就是 `tm_init()`，而且模块还显式的声明了退出函数 `module_exit` ，本处就是 `tm_exit()`，如果模块不打算退出，则可以省略这一步；最后，要注意的是每个模块都需要声明自己采用的协议，内核模块一般都要使用 GPL 协议，这是因为内核本身采用了 GPL 开源协议，如果你的模块使用了内核的东西则也得采用 GPL 协议，否则是无法编译的 —— GPL 具有传染性。

编译模块需要注意两点：必须使用 Makefile 、必须指出内核位置并使用内核函数。

一个最简单的模块基本这样子，实际的模块要比这复杂的多，不过模块的基本元素都已经在这里包括了。


### 2. 加载模块

内核中和可加载模块相关的代码主要是：

```
kernel/module.c
kernel/kmod.c
arch/<arch>/kernel/module.c
```

其中 kernel 下的两个文件是和架构无关的核心代码，arch 下的 module.c 则是和 CPU 硬件实现相关的代码，比如地址布局、对齐等要素。

加载模块有两种途径：使用系统命令 `insmod` 加载和使用代码 `request_module`

### 2.1. insmod 

insmod 加载模块的实现分为两部分：用户空间 `insmod` 命令的实现和内核空间加载模块的实现。

以 [busybox][1] 实现的 `insmod` 为例，首先 busybox 实现了 shell 命令 `insmod` ：


insmod .c

```
int insmod_main(int argc UNUSED_PARAM, char **argv)
{
...

    rc = bb_init_module(filename, parse_cmdline_module_options(argv, /*quote_spaces:*/ 0));
...
}
```

modutils/modutils.c

```
int FAST_FUNC bb_init_module(const char *filename, const char *options)
{
...
    image = try_to_mmap_module(filename, &image_size);
...
    init_module(image, image_size, options);
...
}       

```

modutils/modutils.c

```
# define init_module(mod, len, opts) syscall(__NR_init_module, mod, len, opts)
# define delete_module(mod, flags) syscall(__NR_delete_module, mod, flags)

```

shell 命令 `insmod` 最终就是调用标准库函数的 `syscall(__NR_init_module,...）` 进入系统调用，注意，此时 busybox 要将模块的起始地址、长度、参数告诉给系统调用，否则系统调用是无法获取到模块文件的。到此加载模块的用户空间代码就执行完成了，接下来通过就要进入内核空间的系统调用 `sys_init_module`。

如[Linux系统调用的定义](https://oska874.github.io/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89.html)所述，`sys_init_module` 的实现如下：

`kernel/module.c`

```
SYSCALL_DEFINE3(init_module, void __user *, umod,        
        unsigned long, len, const char __user *, uargs)  
{ 
    int err;   
    struct load_info info = { };   
  
    err = may_init_module();       
    if (err)   
        return err;     
  
    pr_debug("init_module: umod=%p, len=%lu, uargs=%p\n",
  umod, len, uargs);      
  
    err = copy_module_from_user(umod, len, &info);       
    if (err)   
        return err;     
  
    return load_module(&info, uargs, 0); 
}
```

首先系统要检查是否允许加载该模块，然后从用户空间拷贝模块到内核空间(`copy_module_from_user()`)，然后调用 `load_module()` 开始加载模块。


```
static int load_module(struct load_info *info, const char __user *uargs,
      int flags)     
{     
...    
    /* Figure out module layout, and allocate all the memory. */        
    mod = layout_and_allocate(info, flags);       
    if (IS_ERR(mod)) { 
        err = PTR_ERR(mod);   
        goto free_copy;
    } 
    /* Reserve our place in the list. */
    err = add_unformed_module(mod);     
    if (err)      
        goto free_module;      
       
...     
    err = check_module_license_and_versions(mod);  
    if (err)      
        goto free_unload;      
...    
    /* Fix up syms, so that st_value is a pointer to location. */      
    err = simplify_symbols(mod, info);
    if (err < 0)
        goto free_modinfo;   
     
    err = apply_relocations(mod, info); 
    if (err < 0)
        goto free_modinfo;   
     
    err = post_relocation(mod, info); 
    if (err < 0)
        goto free_modinfo;   
...   
    /* Link in to syfs. */     
    err = mod_sysfs_setup(mod, info, mod->kp, mod->num_kp);     
    if (err < 0)  
        goto bug_cleanup;      
       
... 
    return do_init_module(mod);
...     
}        
```

`load_module()` 要干的工作包括为 module 分配内存，检查 module 是否已经加载再将 module 挂到全局的模块链表上，判断模块的版权和版本是否合规，处理模块的各种符号和进行地址重定位、将模块和 sysfs 关联起来，最后一步就是调用 `do_init_module()` 初始化模块。

```
static noinline int do_init_module(struct module *mod)
{
...

    /* Start the module */
    if (mod->init != NULL)
        ret = do_one_initcall(mod->init);
...
    /* Drop initial reference. */
    module_put(mod);
...
    /*
     * We want to free module_init, but be aware that kallsyms may be
     * walking this with preempt disabled.  In all the failure paths, we
     * call synchronize_sched(), but we don't want to slow down the success
     * path, so use actual RCU here.
     */
    call_rcu_sched(&freeinit->rcu, do_free_init);
...
}
```

`do_init_module()` 的主要工作就是调用模块的入口函数（`module_init(...)`)进行模块初始化，最后再释放掉初始化函数。

#### 2.2. request_module

`request_module` 也是一种加载模块的方法，直接在代码里面加载外部模块，它的定义如下：

`kernel/kmod.c`

```
#define request_module(mod...) __request_module(true, mod)

int __request_module(bool wait, const char *fmt, ...)
{
...
    if (!modprobe_path[0])
        return 0;

    va_start(args, fmt);
    ret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);
    va_end(args);
    if (ret >= MODULE_NAME_LEN)
        return -ENAMETOOLONG;

    ...
    ret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);

    atomic_dec(&kmod_concurrent);
    return ret;
}
EXPORT_SYMBOL(__request_module);
```

其中 `modprobe_path` 的定义如下：

```
char modprobe_path[KMOD_PATH_LEN] = "/sbin/modprobe";
```

它指出了我们要用到的用户空间 shell 命令 `modprobe` 的路径。

`request_module()` 首先检查 `modprobe_path` 是否正常，然后调用 `call_modprobe()` 加载模块。 `call_modprobe()` 的定义如下：

```
static int call_modprobe(char *module_name, int wait)
{
    struct subprocess_info *info;
    static char *envp[] = {
        "HOME=/",
        "TERM=linux",
        "PATH=/sbin:/usr/sbin:/bin:/usr/bin",
        NULL
    };

    char **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);
    if (!argv)
        goto out;

    module_name = kstrdup(module_name, GFP_KERNEL);
    if (!module_name)
        goto free_argv;

    argv[0] = modprobe_path;
    argv[1] = "-q";
    argv[2] = "--";
    argv[3] = module_name;  /* check free_modprobe_argv() */
    argv[4] = NULL;

    info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,
 NULL, free_modprobe_argv, NULL);
    if (!info)
        goto free_module_name;

    return call_usermodehelper_exec(info, wait | UMH_KILLABLE);

free_module_name:
    kfree(module_name);
free_argv:
    kfree(argv);
out:
    return -ENOMEM;
}
```

而 `call_modprobe()` 的实现很简单，就是启动一个线程执行用户模式的 `modprobe` 命令加载模块。其中 `envp` 和 `argv` 配置了命令运行环境、命令参数，函数 `call_usermodehelper_setup()` 构造了执行 `modprobe` 的命令结构体，`call_usermodehelper_exec` 用来执行命令。

比如，`request_module("sound-slot-%i", unit>>4);`表示让系统调用用户空间命令 `/sbin/modprobe` 加载名为 `sound-slot-0.ko` 模块。

到此加载模块的两种方法就解释完了，后者实际上就是调用了 `modprobe` 命令。

### 3. 销毁模块

命令 `rmmod` 是用来卸载销毁模块的。在 busybos 中 rmmod 的是这样实现的 ：

```
int rmmod_main(int argc UNUSED_PARAM, char **argv)
{
...
    while (*argv) {
...
        if (bb_delete_module(modname, flags))
   bb_error_msg_and_die("can't unload '%s': %s",
modname, moderror(errno));
    }
...
}

int FAST_FUNC bb_delete_module(const char *module, unsigned int flags)
{
    errno = 0;
    delete_module(module, flags);
    return errno;
}

# define delete_module(mod, flags) syscall(__NR_delete_module, mod, flags)

```

执行了命令 `rmmod` 之后 busybox 最终会调用系统调用 `__NR_delete_module` 进入内核空间。

进入内核空间后，系统会调用删除模块的系统调用 `sys_delete_module` ，它的定义如下：

`kernel/module.c`

```
SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
		unsigned int, flags)
{
...

	mod = find_module(name);
...
	/* Doing init or already dying? */
	if (mod->state != MODULE_STATE_LIVE) {
		/* FIXME: if (force), slam module count damn the torpedoes */
		pr_debug("%s already dying\n", mod->name);
		ret = -EBUSY;
		goto out;
	}

	/* If it has an init func, it must have an exit func to unload */
	if (mod->init && !mod->exit) {
		forced = try_force_unload(flags);
		if (!forced) {
			/* This module can't be removed */
			ret = -EBUSY;
			goto out;
		}
	}

	/* Stop the machine so refcounts can't move and disable module. */
	ret = try_stop_module(mod, flags, &forced);
...
	if (mod->exit != NULL)
		mod->exit();
...

	free_module(mod);
...
}
```

删除模块的过程可以分为这么几步：

1. 找到模块（`find_module()`）
2. 判断模块是否还运行并停止模块运行（`mod->state != MODULE_STATE_LIVE` ， `try_stop_module()`）
3. 执行模块的退出函数（`mod->exit()`）
4. 释放模块占用的资源（`free_module()`）

其中第四步释放模块资源需要释放的资源包括关联的文件项、相关的全局变量和链表、占用的内存等，调用了函数 `free_module()` ：

```
/* Free a module, remove from lists, etc. */     
static void free_module(struct module *mod)      
{      
    trace_module_free(mod);

    mod_sysfs_teardown(mod); 

    /* We leave it in list to prevent duplicate loads, but make sure     
    * that noone uses it while it's being deconstructed. */
    mutex_lock(&module_mutex);   
    mod->state = MODULE_STATE_UNFORMED; 
    mutex_unlock(&module_mutex); 

    /* Remove dynamic debug info */     
    ddebug_remove_module(mod->name);    

    /* Arch-specific cleanup. */ 
    module_arch_cleanup(mod);

    /* Module unload stuff */
    module_unload_free(mod); 

    /* Free any allocated parameters. */
    destroy_params(mod->kp, mod->num_kp);        

    if (is_livepatch_module(mod))
    free_module_elf(mod);

    /* Now we can delete it from the lists */    
    mutex_lock(&module_mutex);   
    /* Unlink carefully: kallsyms could be walking list. */ 
    list_del_rcu(&mod->list);
    mod_tree_remove(mod);  
    /* Remove this module from bug list, this uses list_del_rcu */
    module_bug_cleanup(mod); 
    /* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */
    synchronize_sched();   
    mutex_unlock(&module_mutex); 

    /* This may be empty, but that's OK */       
    disable_ro_nx(&mod->init_layout);   
    module_arch_freeing_init(mod);      
    module_memfree(mod->init_layout.base);       
    kfree(mod->args);      
    percpu_modfree(mod);   

    /* Free lock-classes; relies on the preceding sync_rcu(). */  
    lockdep_free_key_range(mod->core_layout.base, mod->core_layout.size);

    /* Finally, free the core (containing the module structure) */
    disable_ro_nx(&mod->core_layout);   
    module_memfree(mod->core_layout.base);       

    #ifdef CONFIG_MPU 
    update_protections(current->mm);    
    #endif 
}  
```

### 4. 其它 module 相关的命令

和模块相关的除了定义模块、加载模块、删除模块外，还需要了解一些相关的命令（`lsmod` 、 `modprobe` 、 `modinfo`）~~和可执行文件格式 ELF~~。

#### 4.1. lsmod 、 modinfo 和 depmod

lsmod 可以列出系统已经加载的全部模块，modinfo 用来显示指定模块的信息，depmod 给出模块的依赖关系，比如：

lsmod 列出了所有模块的名称、大小、使用状态、被那个系统模块使用这些信息。

```
➜  linux  lsmod
Module  Size  Used by
jffs2  99213  0
mtd52813  1 jffs2
xt_addrtype   12563  2
xt_conntrack  12664  1
ipt_MASQUERADE12760  1
iptable_nat   12867  1
nf_conntrack_ipv4      14492  2
nf_defrag_ipv412649  1 nf_conntrack_ipv4
nf_nat_ipv4   13095  1 iptable_nat
iptable_filter12706  1
ip_tables     17987  2 iptable_filter,iptable_nat
x_tables      22067  5 ip_tables,ipt_MASQUERADE,xt_conntrack,iptable_filter,xt_addrtype
nf_nat 20861  3 ipt_MASQUERADE,nf_nat_ipv4,iptable_nat
nf_conntrack  83685  6 ipt_MASQUERADE,nf_nat,nf_nat_ipv4,xt_conntrack,iptable_nat,nf_conntrack_ipv4
bridge 94737  0
stp12848  1 bridge
llc14160  2 stp,bridge
aufs  176157  0
pci_stub      12550  1
vboxpci22959  0
vboxnetadp    25755  0
...
```

而 modinfo 则会给出指定模块（此处为 jffs2）的模块路径、版权、依赖、作者等信息。

```
➜  linux  modinfo jffs2
filename:       /lib/modules/3.13.0-52-generic/kernel/fs/jffs2/jffs2.ko
license:        GPL
author:Red Hat, Inc.
description:    The Journalling Flash File System, v2
alias: fs-jffs2
srcversion:     9480939EEC3AC916B2F529E
depends:        mtd
intree:Y
vermagic:       3.13.0-52-generic SMP mod_unload modversions 686
signer:Magrathea: Glacier signing key
sig_key:        E1:7C:1A:20:0E:70:82:2E:A7:1B:75:F9:A6:8F:D2:E2:5D:B8:9A:5A
sig_hashalgo:   sha512
```

命令 depmod ：

```
➜  gh  sudo depmod -n /lib/modules/3.13.0-52-generic/kernel/drivers/usb/phy/phy-generic.ko
kernel/drivers/usb/phy/phy-generic.ko:
# Aliases extracted from modules themselves.
alias platform:usb_phy_gen_xceiv phy_generic
alias of:N*T*Cusb-nop-xceiv* phy_generic
# Soft dependencies extracted from modules themselves.
# Copy, with a .conf extension, to /etc/modprobe.d to use it with modprobe.
# Aliases for symbols, used by symbol_request().
alias symbol:usb_phy_gen_create_phy phy_generic
alias symbol:usb_gen_phy_init phy_generic
alias symbol:usb_gen_phy_shutdown phy_generic
alias symbol:usb_nop_xceiv_unregister phy_generic
alias symbol:usb_nop_xceiv_register phy_generic
# Device nodes to trigger on-demand module loading.
```

以 busybox 实现的 lsmod 和 modprobe 为例。

1. lsmod

```
int lsmod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
int lsmod_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
#if ENABLE_FEATURE_LSMOD_PRETTY_2_6_OUTPUT
    char *token[4];
    parser_t *parser = config_open("/proc/modules");
    init_unicode();

    printf("%-24sSize  Used by", "Module");
    check_tainted();

    if (ENABLE_FEATURE_2_4_MODULES
     && get_linux_version_code() < KERNEL_VERSION(2,6,0)
    ) {
        while (config_read(parser, token, 4, 3, "# \t", PARSE_NORMAL)) {
            if (token[3] != NULL && token[3][0] == '[') {
                token[3]++;
                token[3][strlen(token[3])-1] = '\0';
            } else
                token[3] = (char *) "";
# if ENABLE_UNICODE_SUPPORT
            {
                uni_stat_t uni_stat;
                char *uni_name = unicode_conv_to_printable(&uni_stat, token[0]);
                unsigned pad_len = (uni_stat.unicode_width > 19) ? 0 : 19 - uni_stat.unicode_width;
                printf("%s%*s %8s %2s %s\n", uni_name, pad_len, "", token[1], token[2], token[3]);
                free(uni_name);
            }
# else
            printf("%-19s %8s %2s %s\n", token[0], token[1], token[2], token[3]);
# endif
        }
    } else {
        while (config_read(parser, token, 4, 4, "# \t", PARSE_NORMAL & ~PARSE_GREEDY)) {
            // N.B. token[3] is either '-' (module is not used by others)
            // or comma-separated list ended by comma
            // so trimming the trailing char is just what we need!
            if (token[3][0])
                token[3][strlen(token[3]) - 1] = '\0';
# if ENABLE_UNICODE_SUPPORT
            {
                uni_stat_t uni_stat;
                char *uni_name = unicode_conv_to_printable(&uni_stat, token[0]);
                unsigned pad_len = (uni_stat.unicode_width > 19) ? 0 : 19 - uni_stat.unicode_width;
                printf("%s%*s %8s %2s %s\n", uni_name, pad_len, "", token[1], token[2], token[3]);
                free(uni_name);
            }
# else
            printf("%-19s %8s %2s %s\n", token[0], token[1], token[2], token[3]);
# endif
        }
    }
    if (ENABLE_FEATURE_CLEAN_UP)
        config_close(parser);
#else
    check_tainted();
    xprint_and_close_file(xfopen_for_read("/proc/modules"));
#endif
    return EXIT_SUCCESS;
}
```

2. modprobe


```
int modinfo_main(int argc UNUSED_PARAM, char **argv)
{
    struct modinfo_env env;
    char name[MODULE_NAME_LEN];
    struct utsname uts;
    parser_t *parser;
    char *colon, *tokens[2];
    unsigned opts;
    unsigned i;

    env.field = NULL;
    opt_complementary = "-1"; /* minimum one param */
    opts = getopt32(argv, "nladvAsDumpF:0", &env.field);
    env.tags = opts & OPT_TAGS ? opts & OPT_TAGS : OPT_TAGS;
    argv += optind;

    uname(&uts);
    parser = config_open2(
        xasprintf("%s/%s/%s", CONFIG_DEFAULT_MODULES_DIR, uts.release, CONFIG_DEFAULT_DEPMOD_FILE),
        xfopen_for_read
        );

        while (config_read(parser, tokens, 2, 1, "# \t", PARSE_NORMAL)) {
            colon = last_char_is(tokens[0], ':');
            if (colon == NULL)
            continue;
            *colon = '\0';
            filename2modname(bb_basename(tokens[0]), name);
            for (i = 0; argv[i]; i++) {
               if (fnmatch(argv[i], name, 0) == 0) {
                modinfo(tokens[0], uts.release, &env);
                argv[i] = (char *) "";
            }
        }
    }
    if (ENABLE_FEATURE_CLEAN_UP)
    config_close(parser);

    for (i = 0; argv[i]; i++) {
        if (argv[i][0]) {
           modinfo(argv[i], uts.release, &env);
       }
   }

   return 0;
}

static void modinfo(const char *path, const char *version,
   const struct modinfo_env *env)     
{    
    static const char *const shortcuts[] = {   
        "filename", 
        "license", 
        "author",  
        "description",
        "version",   
        "alias",
        "srcversion",
        "depends",
        "uts_release", 
        "vermagic", 
        "parm",  
        "firmware", 
    };       
    size_t len;  
    int j;
    char *ptr, *the_module;
    const char *field = env->field;   
    int tags = env->tags;

    if (tags & 1) { /* filename */    
        display(path, shortcuts[0], 1 != tags);
    }        
    len = MAXINT(ssize_t); 
    the_module = xmalloc_open_zipped_read_close(path, &len);
    if (!the_module) {   
        if (path[0] == '/')
        return;      
        /* Newer depmod puts relative paths in modules.dep */   
        path = xasprintf("%s/%s/%s", CONFIG_DEFAULT_MODULES_DIR, version, path);
        the_module = xmalloc_open_zipped_read_close(path, &len);
        free((char*)path); 
        if (!the_module) 
        return;      
    }

    if (field)
        tags |= OPT_F;   
    for (j = 1; (1<<j) & (OPT_TAGS + OPT_F); j++) {       
        const char *pattern;   

        if (!((1<<j) & tags))  
            continue;    
        pattern = field; 
        if ((1<<j) & OPT_TAGS) 
            pattern = shortcuts[j];   
        ptr = the_module;
        while (1) {      
            char *after_pattern;      

            ptr = memchr(ptr, *pattern, len - (ptr - (char*)the_module));       
            if (ptr == NULL) /* no occurance left, done */
                break;  
            after_pattern = is_prefixed_with(ptr, pattern); 
            if (after_pattern && *after_pattern == '=') { 
                /* field prefixes are 0x80 or 0x00 */     
                if ((ptr[-1] & 0x7F) == 0x00) {  
                    ptr = after_pattern + 1;     
                    display(ptr, pattern, (1<<j) != tags);
                    ptr += strlen(ptr);   
                }        
            }   
            ++ptr;       
        }
    }
    free(the_module);    
}
```

3. 小结

lsmod 和 modinfo 两个命令的实现其实就是直接读取 Linux 的系统文件来获取模块的信息，并不直接域内核函数或系统调用发生关系： lsmod 就是读取 `/proc/modules` 的内容，modinfo 的信息是从 `/lib/modules` 和模块文件获取的。

#### 4.2. modprobe   






```
kernel/module.c
kernel/kmod.c
arch/<arch>/kernel/module.c
```



---

[1]: https://busybox.net/about.html


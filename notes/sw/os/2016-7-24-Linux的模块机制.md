---
title: 2016-7-24-Linux的模块机制 
tags : [ Kernel , Linux ]
---

Linux Kernel 是宏内核，和微内核相对的，它的所有内核内核功能的实现都在内核之中，所以相对于微内核实现， Linux Kernel 就是一个“巨无霸”。宏内核的好处是系统运行中性能相对好，不容易受到其他代码的影响，但是缺点不够灵活，如果 Linux Kernel 完全这样做的话，那么就会出现一种情况：哪怕添加一个很小的功能，都得把整个内核重新编译、更新，而且最终的内核将会十分巨大，甚至不能满足引导系统（如 uboot）对内核镜像大小的要求。为了解决这个问题， Linux 在宏内核的基础上采用了可加载模块机制，即将 Kernel 的绝大部分功能都和核心模块编译成一个独立的内核镜像，然后如果你要给内核添加你需要的功能，那么你可以按照 Kernel 的要求规范编写模块（module），在系统启动后将 module 加载到内核空间，这样既可以保证系统的高性能和可靠性，也可以保证系统必要的灵活性，方便的增加新功能，实际上很多需要运行在内核态的功能都是以可加载模块的形式实现的，比如很多驱动程序都是以 module 的形式使用的，除此之外，还有一种使用模块的原因：厂商不愿意开放源代码而通过可加载模块规避版权限制。

Linux 的模块机制可以简单的分为：


### 1. 构建模块

linux 的模块有专门的编写规范：入口（module_init）、出口（module_exit）和声明信息，最简单的模块就包括这些：


```
/*tm.c*/

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ezio");
MODULE_DESCRIPTION("A simple Linux module");
MODULE_VERSION("0.1");

static int __init tm_init(void){
   int result = 0;

   printk(KERN_INFO "Hello Module\n");
   return 0;
}


static void __exit tm_exit(void){
   printk(KERN_INFO "Bye Module\n");
}

module_init(tm_init);
module_exit(tm_exit);
```

```
/*Makefile */
obj-m += tm.o

KERNEL_PATH := ***

all:
	make -C $(KERNEL_PATH) M=$(PWD) modules
clean:
	make -C $(KERNEL_PATH) M=$(PWD) clean
```

首先，模块使用的函数库和一般的应用程序不同，并没有使用标准库函数和系统库函数，而是用的内核函数和内核头文件，比如头文件引用的是 `module.h` ，打印使用了 `printk()` 而不是 `printf()` ；然后，模块的入口不像普通应用程序使用 `main()` ，而是 `module_init` 声明的函数，本处就是 `tm_init()`，而且模块还显式的声明了退出函数 `module_exit` ，本处就是 `tm_exit()`，如果模块不打算退出，则可以省略这一步；最后，要注意的是每个模块都需要声明自己采用的协议，内核模块一般都要使用 GPL 协议，这是因为内核本身采用了 GPL 开源协议，如果你的模块使用了内核的东西则也得采用 GPL 协议，否则是无法编译的 —— GPL 具有传染性。

编译模块需要注意两点：必须使用 Makefile 、必须指出内核位置并使用内核函数。

一个最简单的模块基本这样子，实际的模块要比这复杂的多，不过模块的基本元素都已经在这里包括了。


### 2. 加载模块

内核中和可加载模块相关的代码主要是：

```
kernel/module.c
kernel/kmod.c
arch/<arch>/kernel/module.c
```

其中 kernel 下的两个文件是和架构无关的核心代码，arch 下的 module.c 则是和 CPU 硬件实现相关的代码，比如地址布局、对齐等要素。

加载模块有两种途径：使用系统命令 `insmod` 加载和使用代码 `request_module`

### 2.1. insmod 

insmod 加载模块的实现分为两部分：用户空间 `insmod` 命令的实现和内核空间加载模块的实现。

以 [busybox][1] 实现的 `insmod` 为例，首先 busybox 实现了 shell 命令 `insmod` ：


insmod .c

```
int insmod_main(int argc UNUSED_PARAM, char **argv)
{
...

    rc = bb_init_module(filename, parse_cmdline_module_options(argv, /*quote_spaces:*/ 0));
...
}
```

modutils/modutils.c

```
int FAST_FUNC bb_init_module(const char *filename, const char *options)
{
...
    image = try_to_mmap_module(filename, &image_size);
...
    init_module(image, image_size, options);
...
}       

```

modutils/modutils.c

```
# define init_module(mod, len, opts) syscall(__NR_init_module, mod, len, opts)
# define delete_module(mod, flags) syscall(__NR_delete_module, mod, flags)

```

shell 命令 `insmod` 最终就是调用标准库函数的 `syscall(__NR_init_module,...）` 进入系统调用，注意，此时 busybox 要将模块的起始地址、长度、参数告诉给系统调用，否则系统调用是无法获取到模块文件的。到此加载模块的用户空间代码就执行完成了，接下来通过就要进入内核空间的系统调用 `sys_init_module`。

如[Linux系统调用的定义](https://oska874.github.io/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89.html)所述，sys_init_module 的实现如下：


kernel/module.c

```
SYSCALL_DEFINE3(init_module, void __user *, umod,        
        unsigned long, len, const char __user *, uargs)  
{                                                        
    int err;                                             
    struct load_info info = { };                         
                                                         
    err = may_init_module();                             
    if (err)                                             
        return err;                                      
                                                         
    pr_debug("init_module: umod=%p, len=%lu, uargs=%p\n",
           umod, len, uargs);                            
                                                         
    err = copy_module_from_user(umod, len, &info);       
    if (err)                                             
        return err;                                      
                                                         
    return load_module(&info, uargs, 0);                 
}
```

首先系统要检查是否允许加载该模块，然后从用户空间拷贝模块到内核空间，然后调用 `load_module()` 开始加载模块。


```
static int load_module(struct load_info *info, const char __user *uargs,
               int flags)                                               
{                                                                       
    struct module *mod;                                                 
    long err;                                                           
    char *after_dashes;                                                 
                                                                        
    err = module_sig_check(info);                                       
    if (err)                                                            
        goto free_copy;                                                 
                                                                        
    err = elf_header_check(info);                                       
    if (err)                                                            
        goto free_copy;                                                 
                                                                        
    /* Figure out module layout, and allocate all the memory. */        
    mod = layout_and_allocate(info, flags);                             
    if (IS_ERR(mod)) {                                                  
        err = PTR_ERR(mod);                                             
        goto free_copy;                                                 
    }                                                                   
    /* Reserve our place in the list. */                                 
    err = add_unformed_module(mod);                                      
    if (err)                                                             
        goto free_module;                                                
                                                                         
#ifdef CONFIG_MODULE_SIG                                                 
    mod->sig_ok = info->sig_ok;                                          
    if (!mod->sig_ok) {                                                  
        pr_notice_once("%s: module verification failed: signature "      
                   "and/or required key missing - tainting "             
                   "kernel\n", mod->name);                               
        add_taint_module(mod, TAINT_UNSIGNED_MODULE, LOCKDEP_STILL_OK);  
    }                                                                    
#endif                                                                   
                                                                         
    /* To avoid stressing percpu allocator, do this once we're unique. */
    err = percpu_modalloc(mod, info);                                    
    if (err)                                                             
        goto unlink_mod;                                                 
                                                                         
    /* Now module is in final location, initialize linked lists, etc. */ 
    err = module_unload_init(mod);                                       
    if (err)                                                             
        goto unlink_mod;                                                 
                                                                         
    /* Now we've got everything in the final locations, we can           
     * find optional sections. */                                        
    err = find_module_sections(mod, info);                               
    if (err)                                                             
        goto free_unload;                                                
                                                                         
    err = check_module_license_and_versions(mod);                        
    if (err)                                                             
        goto free_unload;                                                
    /* Set up MODINFO_ATTR fields */                                   
    setup_modinfo(mod, info);                                          
                                                                       
    /* Fix up syms, so that st_value is a pointer to location. */      
    err = simplify_symbols(mod, info);                                 
    if (err < 0)                                                       
        goto free_modinfo;                                             
                                                                       
    err = apply_relocations(mod, info);                                
    if (err < 0)                                                       
        goto free_modinfo;                                             
                                                                       
    err = post_relocation(mod, info);                                  
    if (err < 0)                                                       
        goto free_modinfo;                                             
                                                                       
    flush_module_icache(mod);                                          
                                                                       
    /* Now copy in args */                                             
    mod->args = strndup_user(uargs, ~0UL >> 1);                        
    if (IS_ERR(mod->args)) {                                           
        err = PTR_ERR(mod->args);                                      
        goto free_arch_cleanup;                                        
    }                                                                  
                                                                       
    dynamic_debug_setup(info->debug, info->num_debug);                 
                                                                       
    /* Ftrace init must be called in the MODULE_STATE_UNFORMED state */
    ftrace_module_init(mod);                                           
                                                                       
    /* Finally it's fully formed, ready to start executing. */         
    err = complete_formation(mod, info);                               
    if (err)                                                           
        goto ddebug_cleanup;                                             
                                                                         
    /* Module is ready to execute: parsing args may do that. */          
    after_dashes = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,
                  -32768, 32767, unknown_module_param_cb);               
    if (IS_ERR(after_dashes)) {                                          
        err = PTR_ERR(after_dashes);                                     
        goto bug_cleanup;                                                
    } else if (after_dashes) {                                           
        pr_warn("%s: parameters '%s' after `--' ignored\n",              
               mod->name, after_dashes);                                 
    }                                                                    
                                                                         
    /* Link in to syfs. */                                               
    err = mod_sysfs_setup(mod, info, mod->kp, mod->num_kp);              
    if (err < 0)                                                         
        goto bug_cleanup;                                                
                                                                         
    /* Get rid of temporary copy. */                                     
    free_copy(info);                                                     
                                                                         
    /* Done! */                                                          
    trace_module_load(mod);                                              
                                                                         
    return do_init_module(mod);                                          
                                                                         
 bug_cleanup:                                                            
    /* module_bug_cleanup needs module_mutex protection */               
    mutex_lock(&module_mutex);                                           
    module_bug_cleanup(mod);                                             
    mutex_unlock(&module_mutex);                                         
                                                                         
    blocking_notifier_call_chain(&module_notify_list,                    
                     MODULE_STATE_GOING, mod);                           
                                                                         
    /* we can't deallocate the module until we clear memory protection */
    unset_module_init_ro_nx(mod);                                        
    unset_module_core_ro_nx(mod);                                        
 ddebug_cleanup:                                                
    dynamic_debug_remove(info->debug);                          
    synchronize_sched();                                        
    kfree(mod->args);                                           
 free_arch_cleanup:                                             
    module_arch_cleanup(mod);                                   
 free_modinfo:                                                  
    free_modinfo(mod);                                          
 free_unload:                                                   
    module_unload_free(mod);                                    
 unlink_mod:                                                    
    mutex_lock(&module_mutex);                                  
    /* Unlink carefully: kallsyms could be walking list. */     
    list_del_rcu(&mod->list);                                   
    wake_up_all(&module_wq);                                    
    /* Wait for RCU synchronizing before releasing mod->list. */
    synchronize_rcu();                                          
    mutex_unlock(&module_mutex);                                
 free_module:                                                   
    /* Free lock-classes; relies on the preceding sync_rcu() */ 
    lockdep_free_key_range(mod->module_core, mod->core_size);   
                                                                
    module_deallocate(mod, info);                               
 free_copy:                                                     
    free_copy(info);                                            
    return err;                                                 
}                                                               
```







request_module("sound-slot-%i", unit>>4);函数,这表示,让linux系统的用户空间调用/sbin/modprobe函数加载名为sound-slot-0.ko模块


### 3. 销毁模块

命令 `rmmod` 和


```
SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
		unsigned int, flags)
{
	struct module *mod;
	char name[MODULE_NAME_LEN];
	int ret, forced = 0;

	if (!capable(CAP_SYS_MODULE) || modules_disabled)
		return -EPERM;

	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
		return -EFAULT;
	name[MODULE_NAME_LEN-1] = '\0';

	if (mutex_lock_interruptible(&module_mutex) != 0)
		return -EINTR;

	mod = find_module(name);
	if (!mod) {
		ret = -ENOENT;
		goto out;
	}

	if (!list_empty(&mod->source_list)) {
		/* Other modules depend on us: get rid of them first. */
		ret = -EWOULDBLOCK;
		goto out;
	}

	/* Doing init or already dying? */
	if (mod->state != MODULE_STATE_LIVE) {
		/* FIXME: if (force), slam module count damn the torpedoes */
		pr_debug("%s already dying\n", mod->name);
		ret = -EBUSY;
		goto out;
	}

	/* If it has an init func, it must have an exit func to unload */
	if (mod->init && !mod->exit) {
		forced = try_force_unload(flags);
		if (!forced) {
			/* This module can't be removed */
			ret = -EBUSY;
			goto out;
		}
	}

	/* Stop the machine so refcounts can't move and disable module. */
	ret = try_stop_module(mod, flags, &forced);
	if (ret != 0)
		goto out;

	mutex_unlock(&module_mutex);
	/* Final destruction now no one is using it. */
	if (mod->exit != NULL)
		mod->exit();
	blocking_notifier_call_chain(&module_notify_list,
				     MODULE_STATE_GOING, mod);
	klp_module_going(mod);
	ftrace_release_mod(mod);

	async_synchronize_full();

	/* Store the name of the last unloaded module for diagnostic purposes */
	strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));

	free_module(mod);
	return 0;
out:
	mutex_unlock(&module_mutex);
	return ret;
}
```

4. 其它 module 相关的命令

、 modprobe 、  、 lsmod 、 modinfo



```
kernel/module.c
kernel/kmod.c
arch/<arch>/kernel/module.c
```



---

[1]: https://busybox.net/about.html

